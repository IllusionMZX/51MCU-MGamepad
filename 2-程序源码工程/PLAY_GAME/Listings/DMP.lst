C51 COMPILER V9.60.7.0   DMP                                                               12/06/2024 10:38:26 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE DMP
OBJECT MODULE PLACED IN .\Objects\DMP.obj
COMPILER INVOKED BY: E:\Program Files\Keil_v5\Keil_arm\C51\BIN\C51.EXE DMP.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJECT
                    -EXTEND PRINT(.\Listings\DMP.lst) OBJECT(.\Objects\DMP.obj)

line level    source

   1          /*****************************************************
   2          功能:   采集MPU6050 DMP 数据
   3          CPU:    STC89C52Rc
   4          晶震:   11.0592
   5          语言:   c
   6          来源：  移植 Jeff Jrowberg 公开的程序。
   7          目的：
   8          sda 或则scl 为高时是:释放总线
   9          *****************************************************/
  10          #include "Soft_I2C.h"
  11          #include "MPU6050.h"
  12          
  13          float Q[4];     //四元数
  14          
  15          uint8_t dmpdatas[42];   //DMP数据
  16          
  17          //以下的 firmware 及 config update 数据来自于 Jeff Jrowberg 公开的程序
  18          /* ================================================================================================ *
  19          | Default MotionApps v2.0 42-byte FIFO packet structure:                                           |
  20          |                                                                                                  |
  21          | [QUAT W][      ][QUAT X][      ][QUAT Y][      ][QUAT Z][      ][GYRO X][      ][GYRO Y][      ] |
  22          |   0   1   2   3   4   5   6   7   8   9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  |
  23          |                                                                                                  |
  24          | [GYRO Z][      ][ACC X ][      ][ACC Y ][      ][ACC Z ][      ][      ]                         |
  25          |  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41                          |
  26          * ================================================================================================ */
  27          code uint8_t dmpmemorydata[1929] = {
  28              // bank 0, 256 bytes
  29              0xFB, 0x00, 0x00, 0x3E, 0x00, 0x0B, 0x00, 0x36, 0x00, 0x01, 0x00, 0x02, 0x00, 0x03, 0x00, 0x00,
  30              0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0xFA, 0x80, 0x00, 0x0B, 0x12, 0x82, 0x00, 0x01,
  31              0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  32              0x00, 0x28, 0x00, 0x00, 0xFF, 0xFF, 0x45, 0x81, 0xFF, 0xFF, 0xFA, 0x72, 0x00, 0x00, 0x00, 0x00,
  33              0x00, 0x00, 0x03, 0xE8, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x7F, 0xFF, 0xFF, 0xFE, 0x80, 0x01,
  34              0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  35              0x00, 0x3E, 0x03, 0x30, 0x40, 0x00, 0x00, 0x00, 0x02, 0xCA, 0xE3, 0x09, 0x3E, 0x80, 0x00, 0x00,
  36              0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00, 0x00, 0x00,
  37              0x41, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x0B, 0x2A, 0x00, 0x00, 0x16, 0x55, 0x00, 0x00, 0x21, 0x82,
  38              0xFD, 0x87, 0x26, 0x50, 0xFD, 0x80, 0x00, 0x00, 0x00, 0x1F, 0x00, 0x00, 0x00, 0x05, 0x80, 0x00,
  39              0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00,
  40              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x6F, 0x00, 0x02, 0x65, 0x32, 0x00, 0x00, 0x5E, 0xC0,
  41              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  42              0xFB, 0x8C, 0x6F, 0x5D, 0xFD, 0x5D, 0x08, 0xD9, 0x00, 0x7C, 0x73, 0x3B, 0x00, 0x6C, 0x12, 0xCC,
  43              0x32, 0x00, 0x13, 0x9D, 0x32, 0x00, 0xD0, 0xD6, 0x32, 0x00, 0x08, 0x00, 0x40, 0x00, 0x01, 0xF4,
  44              0xFF, 0xE6, 0x80, 0x79, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0xD0, 0xD6, 0x00, 0x00, 0x27, 0x10,
  45              // bank 1, 256 bytes
  46              0xFB, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  47              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x00, 0x01, 0x00, 0x00, 0x00,
  48              0x00, 0x00, 0xFA, 0x36, 0xFF, 0xBC, 0x30, 0x8E, 0x00, 0x05, 0xFB, 0xF0, 0xFF, 0xD9, 0x5B, 0xC8,
  49              0xFF, 0xD0, 0x9A, 0xBE, 0x00, 0x00, 0x10, 0xA9, 0xFF, 0xF4, 0x1E, 0xB2, 0x00, 0xCE, 0xBB, 0xF7,
  50              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x04, 0x00, 0x02, 0x00, 0x02, 0x02, 0x00, 0x00, 0x0C,
  51              0xFF, 0xC2, 0x80, 0x00, 0x00, 0x01, 0x80, 0x00, 0x00, 0xCF, 0x80, 0x00, 0x40, 0x00, 0x00, 0x00,
  52              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x00, 0x14,
  53              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  54              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
C51 COMPILER V9.60.7.0   DMP                                                               12/06/2024 10:38:26 PAGE 2   

  55              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  56              0x00, 0x00, 0x00, 0x00, 0x03, 0x3F, 0x68, 0xB6, 0x79, 0x35, 0x28, 0xBC, 0xC6, 0x7E, 0xD1, 0x6C,
  57              0x80, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0xB2, 0x6A, 0x00, 0x00, 0x00, 0x00,
  58              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0xF0, 0x00, 0x00, 0x00, 0x30,
  59              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  60              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  61              0x00, 0x00, 0x25, 0x4D, 0x00, 0x2F, 0x70, 0x6D, 0x00, 0x00, 0x05, 0xAE, 0x00, 0x0C, 0x02, 0xD0,
  62              // bank 2, 256 bytes
  63              0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x54, 0xFF, 0xEF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  64              0x00, 0x00, 0x01, 0x00, 0x00, 0x44, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x00, 0x00, 0x00, 0x01, 0x00,
  65              0x00, 0x00, 0x00, 0x00, 0x00, 0x65, 0x00, 0x00, 0x00, 0x54, 0x00, 0x00, 0xFF, 0xEF, 0x00, 0x00,
  66              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  67              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  68              0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  69              0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  70              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  71              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  72              0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  73              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  74              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00,
  75              0x00, 0x1B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  76              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  77              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  78              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  79              // bank 3, 256 bytes
  80              0xD8, 0xDC, 0xBA, 0xA2, 0xF1, 0xDE, 0xB2, 0xB8, 0xB4, 0xA8, 0x81, 0x91, 0xF7, 0x4A, 0x90, 0x7F,
  81              0x91, 0x6A, 0xF3, 0xF9, 0xDB, 0xA8, 0xF9, 0xB0, 0xBA, 0xA0, 0x80, 0xF2, 0xCE, 0x81, 0xF3, 0xC2,
  82              0xF1, 0xC1, 0xF2, 0xC3, 0xF3, 0xCC, 0xA2, 0xB2, 0x80, 0xF1, 0xC6, 0xD8, 0x80, 0xBA, 0xA7, 0xDF,
  83              0xDF, 0xDF, 0xF2, 0xA7, 0xC3, 0xCB, 0xC5, 0xB6, 0xF0, 0x87, 0xA2, 0x94, 0x24, 0x48, 0x70, 0x3C,
  84              0x95, 0x40, 0x68, 0x34, 0x58, 0x9B, 0x78, 0xA2, 0xF1, 0x83, 0x92, 0x2D, 0x55, 0x7D, 0xD8, 0xB1,
  85              0xB4, 0xB8, 0xA1, 0xD0, 0x91, 0x80, 0xF2, 0x70, 0xF3, 0x70, 0xF2, 0x7C, 0x80, 0xA8, 0xF1, 0x01,
  86              0xB0, 0x98, 0x87, 0xD9, 0x43, 0xD8, 0x86, 0xC9, 0x88, 0xBA, 0xA1, 0xF2, 0x0E, 0xB8, 0x97, 0x80,
  87              0xF1, 0xA9, 0xDF, 0xDF, 0xDF, 0xAA, 0xDF, 0xDF, 0xDF, 0xF2, 0xAA, 0xC5, 0xCD, 0xC7, 0xA9, 0x0C,
  88              0xC9, 0x2C, 0x97, 0x97, 0x97, 0x97, 0xF1, 0xA9, 0x89, 0x26, 0x46, 0x66, 0xB0, 0xB4, 0xBA, 0x80,
  89              0xAC, 0xDE, 0xF2, 0xCA, 0xF1, 0xB2, 0x8C, 0x02, 0xA9, 0xB6, 0x98, 0x00, 0x89, 0x0E, 0x16, 0x1E,
  90              0xB8, 0xA9, 0xB4, 0x99, 0x2C, 0x54, 0x7C, 0xB0, 0x8A, 0xA8, 0x96, 0x36, 0x56, 0x76, 0xF1, 0xB9,
  91              0xAF, 0xB4, 0xB0, 0x83, 0xC0, 0xB8, 0xA8, 0x97, 0x11, 0xB1, 0x8F, 0x98, 0xB9, 0xAF, 0xF0, 0x24,
  92              0x08, 0x44, 0x10, 0x64, 0x18, 0xF1, 0xA3, 0x29, 0x55, 0x7D, 0xAF, 0x83, 0xB5, 0x93, 0xAF, 0xF0,
  93              0x00, 0x28, 0x50, 0xF1, 0xA3, 0x86, 0x9F, 0x61, 0xA6, 0xDA, 0xDE, 0xDF, 0xD9, 0xFA, 0xA3, 0x86,
  94              0x96, 0xDB, 0x31, 0xA6, 0xD9, 0xF8, 0xDF, 0xBA, 0xA6, 0x8F, 0xC2, 0xC5, 0xC7, 0xB2, 0x8C, 0xC1,
  95              0xB8, 0xA2, 0xDF, 0xDF, 0xDF, 0xA3, 0xDF, 0xDF, 0xDF, 0xD8, 0xD8, 0xF1, 0xB8, 0xA8, 0xB2, 0x86,
  96              // bank 4, 256 bytes
  97              0xB4, 0x98, 0x0D, 0x35, 0x5D, 0xB8, 0xAA, 0x98, 0xB0, 0x87, 0x2D, 0x35, 0x3D, 0xB2, 0xB6, 0xBA,
  98              0xAF, 0x8C, 0x96, 0x19, 0x8F, 0x9F, 0xA7, 0x0E, 0x16, 0x1E, 0xB4, 0x9A, 0xB8, 0xAA, 0x87, 0x2C,
  99              0x54, 0x7C, 0xB9, 0xA3, 0xDE, 0xDF, 0xDF, 0xA3, 0xB1, 0x80, 0xF2, 0xC4, 0xCD, 0xC9, 0xF1, 0xB8,
 100              0xA9, 0xB4, 0x99, 0x83, 0x0D, 0x35, 0x5D, 0x89, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0xB5, 0x93, 0xA3,
 101              0x0E, 0x16, 0x1E, 0xA9, 0x2C, 0x54, 0x7C, 0xB8, 0xB4, 0xB0, 0xF1, 0x97, 0x83, 0xA8, 0x11, 0x84,
 102              0xA5, 0x09, 0x98, 0xA3, 0x83, 0xF0, 0xDA, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xD8, 0xF1, 0xA5,
 103              0x29, 0x55, 0x7D, 0xA5, 0x85, 0x95, 0x02, 0x1A, 0x2E, 0x3A, 0x56, 0x5A, 0x40, 0x48, 0xF9, 0xF3,
 104              0xA3, 0xD9, 0xF8, 0xF0, 0x98, 0x83, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0x97, 0x82, 0xA8, 0xF1,
 105              0x11, 0xF0, 0x98, 0xA2, 0x24, 0x08, 0x44, 0x10, 0x64, 0x18, 0xDA, 0xF3, 0xDE, 0xD8, 0x83, 0xA5,
 106              0x94, 0x01, 0xD9, 0xA3, 0x02, 0xF1, 0xA2, 0xC3, 0xC5, 0xC7, 0xD8, 0xF1, 0x84, 0x92, 0xA2, 0x4D,
 107              0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
 108              0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0x93, 0xA3, 0x4D,
 109              0xDA, 0x2A, 0xD8, 0x48, 0x69, 0xD9, 0x2A, 0xD8, 0x68, 0x55, 0xDA, 0x32, 0xD8, 0x50, 0x71, 0xD9,
 110              0x32, 0xD8, 0x70, 0x5D, 0xDA, 0x3A, 0xD8, 0x58, 0x79, 0xD9, 0x3A, 0xD8, 0x78, 0xA8, 0x8A, 0x9A,
 111              0xF0, 0x28, 0x50, 0x78, 0x9E, 0xF3, 0x88, 0x18, 0xF1, 0x9F, 0x1D, 0x98, 0xA8, 0xD9, 0x08, 0xD8,
 112              0xC8, 0x9F, 0x12, 0x9E, 0xF3, 0x15, 0xA8, 0xDA, 0x12, 0x10, 0xD8, 0xF1, 0xAF, 0xC8, 0x97, 0x87,
 113              // bank 5, 256 bytes
 114              0x34, 0xB5, 0xB9, 0x94, 0xA4, 0x21, 0xF3, 0xD9, 0x22, 0xD8, 0xF2, 0x2D, 0xF3, 0xD9, 0x2A, 0xD8,
 115              0xF2, 0x35, 0xF3, 0xD9, 0x32, 0xD8, 0x81, 0xA4, 0x60, 0x60, 0x61, 0xD9, 0x61, 0xD8, 0x6C, 0x68,
 116              0x69, 0xD9, 0x69, 0xD8, 0x74, 0x70, 0x71, 0xD9, 0x71, 0xD8, 0xB1, 0xA3, 0x84, 0x19, 0x3D, 0x5D,
C51 COMPILER V9.60.7.0   DMP                                                               12/06/2024 10:38:26 PAGE 3   

 117              0xA3, 0x83, 0x1A, 0x3E, 0x5E, 0x93, 0x10, 0x30, 0x81, 0x10, 0x11, 0xB8, 0xB0, 0xAF, 0x8F, 0x94,
 118              0xF2, 0xDA, 0x3E, 0xD8, 0xB4, 0x9A, 0xA8, 0x87, 0x29, 0xDA, 0xF8, 0xD8, 0x87, 0x9A, 0x35, 0xDA,
 119              0xF8, 0xD8, 0x87, 0x9A, 0x3D, 0xDA, 0xF8, 0xD8, 0xB1, 0xB9, 0xA4, 0x98, 0x85, 0x02, 0x2E, 0x56,
 120              0xA5, 0x81, 0x00, 0x0C, 0x14, 0xA3, 0x97, 0xB0, 0x8A, 0xF1, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9,
 121              0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x84, 0x0D, 0xDA, 0x0E, 0xD8, 0xA3, 0x29, 0x83, 0xDA,
 122              0x2C, 0x0E, 0xD8, 0xA3, 0x84, 0x49, 0x83, 0xDA, 0x2C, 0x4C, 0x0E, 0xD8, 0xB8, 0xB0, 0xA8, 0x8A,
 123              0x9A, 0xF5, 0x20, 0xAA, 0xDA, 0xDF, 0xD8, 0xA8, 0x40, 0xAA, 0xD0, 0xDA, 0xDE, 0xD8, 0xA8, 0x60,
 124              0xAA, 0xDA, 0xD0, 0xDF, 0xD8, 0xF1, 0x97, 0x86, 0xA8, 0x31, 0x9B, 0x06, 0x99, 0x07, 0xAB, 0x97,
 125              0x28, 0x88, 0x9B, 0xF0, 0x0C, 0x20, 0x14, 0x40, 0xB8, 0xB0, 0xB4, 0xA8, 0x8C, 0x9C, 0xF0, 0x04,
 126              0x28, 0x51, 0x79, 0x1D, 0x30, 0x14, 0x38, 0xB2, 0x82, 0xAB, 0xD0, 0x98, 0x2C, 0x50, 0x50, 0x78,
 127              0x78, 0x9B, 0xF1, 0x1A, 0xB0, 0xF0, 0x8A, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x8B, 0x29, 0x51, 0x79,
 128              0x8A, 0x24, 0x70, 0x59, 0x8B, 0x20, 0x58, 0x71, 0x8A, 0x44, 0x69, 0x38, 0x8B, 0x39, 0x40, 0x68,
 129              0x8A, 0x64, 0x48, 0x31, 0x8B, 0x30, 0x49, 0x60, 0xA5, 0x88, 0x20, 0x09, 0x71, 0x58, 0x44, 0x68,
 130              // bank 6, 256 bytes
 131              0x11, 0x39, 0x64, 0x49, 0x30, 0x19, 0xF1, 0xAC, 0x00, 0x2C, 0x54, 0x7C, 0xF0, 0x8C, 0xA8, 0x04,
 132              0x28, 0x50, 0x78, 0xF1, 0x88, 0x97, 0x26, 0xA8, 0x59, 0x98, 0xAC, 0x8C, 0x02, 0x26, 0x46, 0x66,
 133              0xF0, 0x89, 0x9C, 0xA8, 0x29, 0x51, 0x79, 0x24, 0x70, 0x59, 0x44, 0x69, 0x38, 0x64, 0x48, 0x31,
 134              0xA9, 0x88, 0x09, 0x20, 0x59, 0x70, 0xAB, 0x11, 0x38, 0x40, 0x69, 0xA8, 0x19, 0x31, 0x48, 0x60,
 135              0x8C, 0xA8, 0x3C, 0x41, 0x5C, 0x20, 0x7C, 0x00, 0xF1, 0x87, 0x98, 0x19, 0x86, 0xA8, 0x6E, 0x76,
 136              0x7E, 0xA9, 0x99, 0x88, 0x2D, 0x55, 0x7D, 0x9E, 0xB9, 0xA3, 0x8A, 0x22, 0x8A, 0x6E, 0x8A, 0x56,
 137              0x8A, 0x5E, 0x9F, 0xB1, 0x83, 0x06, 0x26, 0x46, 0x66, 0x0E, 0x2E, 0x4E, 0x6E, 0x9D, 0xB8, 0xAD,
 138              0x00, 0x2C, 0x54, 0x7C, 0xF2, 0xB1, 0x8C, 0xB4, 0x99, 0xB9, 0xA3, 0x2D, 0x55, 0x7D, 0x81, 0x91,
 139              0xAC, 0x38, 0xAD, 0x3A, 0xB5, 0x83, 0x91, 0xAC, 0x2D, 0xD9, 0x28, 0xD8, 0x4D, 0xD9, 0x48, 0xD8,
 140              0x6D, 0xD9, 0x68, 0xD8, 0x8C, 0x9D, 0xAE, 0x29, 0xD9, 0x04, 0xAE, 0xD8, 0x51, 0xD9, 0x04, 0xAE,
 141              0xD8, 0x79, 0xD9, 0x04, 0xD8, 0x81, 0xF3, 0x9D, 0xAD, 0x00, 0x8D, 0xAE, 0x19, 0x81, 0xAD, 0xD9,
 142              0x01, 0xD8, 0xF2, 0xAE, 0xDA, 0x26, 0xD8, 0x8E, 0x91, 0x29, 0x83, 0xA7, 0xD9, 0xAD, 0xAD, 0xAD,
 143              0xAD, 0xF3, 0x2A, 0xD8, 0xD8, 0xF1, 0xB0, 0xAC, 0x89, 0x91, 0x3E, 0x5E, 0x76, 0xF3, 0xAC, 0x2E,
 144              0x2E, 0xF1, 0xB1, 0x8C, 0x5A, 0x9C, 0xAC, 0x2C, 0x28, 0x28, 0x28, 0x9C, 0xAC, 0x30, 0x18, 0xA8,
 145              0x98, 0x81, 0x28, 0x34, 0x3C, 0x97, 0x24, 0xA7, 0x28, 0x34, 0x3C, 0x9C, 0x24, 0xF2, 0xB0, 0x89,
 146              0xAC, 0x91, 0x2C, 0x4C, 0x6C, 0x8A, 0x9B, 0x2D, 0xD9, 0xD8, 0xD8, 0x51, 0xD9, 0xD8, 0xD8, 0x79,
 147              // bank 7, 138 bytes (remainder)
 148              0xD9, 0xD8, 0xD8, 0xF1, 0x9E, 0x88, 0xA3, 0x31, 0xDA, 0xD8, 0xD8, 0x91, 0x2D, 0xD9, 0x28, 0xD8,
 149              0x4D, 0xD9, 0x48, 0xD8, 0x6D, 0xD9, 0x68, 0xD8, 0xB1, 0x83, 0x93, 0x35, 0x3D, 0x80, 0x25, 0xDA,
 150              0xD8, 0xD8, 0x85, 0x69, 0xDA, 0xD8, 0xD8, 0xB4, 0x93, 0x81, 0xA3, 0x28, 0x34, 0x3C, 0xF3, 0xAB,
 151              0x8B, 0xF8, 0xA3, 0x91, 0xB6, 0x09, 0xB4, 0xD9, 0xAB, 0xDE, 0xFA, 0xB0, 0x87, 0x9C, 0xB9, 0xA3,
 152              0xDD, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x95, 0xF1, 0xA3, 0xA3, 0xA3, 0x9D, 0xF1, 0xA3, 0xA3, 0xA3,
 153              0xA3, 0xF2, 0xA3, 0xB4, 0x90, 0x80, 0xF2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3,
 154              0xA3, 0xB2, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xA3, 0xB0, 0x87, 0xB5, 0x99, 0xF1, 0xA3, 0xA3, 0xA3,
 155              0x98, 0xF1, 0xA3, 0xA3, 0xA3, 0xA3, 0x97, 0xA3, 0xA3, 0xA3, 0xA3, 0xF3, 0x9B, 0xA3, 0xA3, 0xDC,
 156              0xB9, 0xA7, 0xF1, 0x26, 0x26, 0x26, 0xD8, 0xD8, 0xFF
 157          };
 158          
 159          code uint8_t dmpcfgupddata[192] = {
 160          //  dmp config
 161          //  BANK    OFFSET  LENGTH  [DATA]
 162              0x03,   0x7B,   0x03,   0x4C, 0xCD, 0x6C,
 163              0x03,   0xAB,   0x03,   0x36, 0x56, 0x76,
 164              0x00,   0x68,   0x04,   0x02, 0xCB, 0x47, 0xA2,
 165              0x02,   0x18,   0x04,   0x00, 0x05, 0x8B, 0xC1,
 166              0x01,   0x0C,   0x04,   0x00, 0x00, 0x00, 0x00,
 167              0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
 168              0x03,   0x89,   0x03,   0x26, 0x46, 0x66,
 169              0x00,   0x6C,   0x02,   0x20, 0x00,
 170              0x02,   0x40,   0x04,   0x00, 0x00, 0x00, 0x00,
 171              0x02,   0x44,   0x04,   0x00, 0x00, 0x00, 0x00,
 172              0x02,   0x48,   0x04,   0x00, 0x00, 0x00, 0x00,
 173              0x02,   0x4C,   0x04,   0x00, 0x00, 0x00, 0x00,
 174              0x02,   0x50,   0x04,   0x00, 0x00, 0x00, 0x00,
 175              0x02,   0x54,   0x04,   0x00, 0x00, 0x00, 0x00,
 176              0x02,   0x58,   0x04,   0x00, 0x00, 0x00, 0x00,
 177              0x02,   0x5C,   0x04,   0x00, 0x00, 0x00, 0x00,
 178              0x02,   0xBC,   0x04,   0x00, 0x00, 0x00, 0x00,
C51 COMPILER V9.60.7.0   DMP                                                               12/06/2024 10:38:26 PAGE 4   

 179              0x01,   0xEC,   0x04,   0x00, 0x00, 0x40, 0x00,
 180              0x03,   0x7F,   0x06,   0x0C, 0xC9, 0x2C, 0x97, 0x97, 0x97,
 181              0x04,   0x02,   0x03,   0x0D, 0x35, 0x5D,
 182              0x04,   0x09,   0x04,   0x87, 0x2D, 0x35, 0x3D,
 183              0x00,   0xA3,   0x01,   0x00,
 184              0x00,   0x00,   0x00,   0x01,       //这里是开启DMP的特殊中断的
 185              //原程序中此行代码为(这里不一定错)
 186              //0x00,   0x00,   0x00,   0x01,  即LENGTH=0x00，有错
 187              0x07,   0x86,   0x01,   0xFE,
 188              0x07,   0x41,   0x05,   0xF1, 0x20, 0x28, 0x30, 0x38,
 189              0x07,   0x7E,   0x01,   0x30,
 190              0x07,   0x46,   0x01,   0x9A,
 191              0x07,   0x47,   0x04,   0xF1, 0x28, 0x30, 0x38,
 192              0x07,   0x6C,   0x04,   0xF1, 0x28, 0x30, 0x38,
 193              0x02,   0x16,   0x02,   0x00, 0x01,
 194              /* 上行最后一个数据调整FIFO rate :0x01=100HZ,0x02=66HZ,0x03=50HZ ,0x04=40HZ,0x05=33.33HZ,
 195              // 可从 datasheet 公式推算
 196              //dmp updates
 197              0x01,   0xB2,   0x02,   0xFF, 0xFF,
 198              0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
 199              0x01,   0x6A,   0x02,   0x06, 0x00,
 200              0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 201              0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
 202              0x01,   0x62,   0x02,   0x00, 0x00,
 203              0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00*/
 204          };
 205          
 206          code uint8_t dmpUpdates[47] = {
 207              0x01,   0xB2,   0x02,   0xFF, 0xFF,
 208              0x01,   0x90,   0x04,   0x09, 0x23, 0xA1, 0x35,
 209              0x01,   0x6A,   0x02,   0x06, 0x00,
 210              0x01,   0x60,   0x08,   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 211              0x00,   0x60,   0x04,   0x40, 0x00, 0x00, 0x00,
 212              0x01,   0x62,   0x02,   0x00, 0x00,
 213              0x00,   0x60,   0x04,   0x00, 0x40, 0x00, 0x00
 214          
 215          };
 216          
 217          /*
 218          加载 DMP代码到
 219          返回值  (1=成功,0=失败)
 220          */
 221          uint8_t loadfirmware(void)
 222          {
 223   1          uint16_t datanum = 0;       //DMP固件写入标志位
 224   1          uint8_t ye, i/*, j*/;
 225   1          uint8_t bank = 0;   //段（256个数据一段）
 226   1          uint8_t addr = 0;
 227   1      
 228   1          for(; bank < 8; bank++) {
 229   2              if(bank == 7)   //这里的作用就是区分最后一段数据
 230   2                  i = 8;
 231   2              else
 232   2                  i = 16;
 233   2              for(ye = 0; ye < i; ye++) {
 234   3                  MPU_Write_Byte(0x6d, bank);
 235   3                  MPU_Write_Byte(0x6e, addr);
 236   3                  MPU_Write_Len(0x6f, 16, dmpmemorydata + datanum);
 237   3                  datanum += 16;
 238   3                  addr += 16;
 239   3              }
 240   2          }
C51 COMPILER V9.60.7.0   DMP                                                               12/06/2024 10:38:26 PAGE 5   

 241   1          MPU_Write_Byte(0x6d, 7);
 242   1          MPU_Write_Byte(0x6e, addr);
 243   1          MPU_Write_Len(0x6f, 9, dmpmemorydata + datanum);
 244   1          datanum += 9;
 245   1          return 1;
 246   1      }
 247          
 248          uint8_t loadcfgupd(void)        //DMP设置
 249          {
 250   1          uint8_t line;       //一共需要写入30条设置数据
 251   1          uint8_t bank;       //页
 252   1          uint8_t datacounts = 0;     //DMP设置数据标志位
 253   1          uint8_t bytes2write;        //数据长度。
 254   1          uint8_t offset;     //偏移地址
 255   1          uint8_t writingcounts;      //数据写入标志与bytes2write一同使用
 256   1          uint8_t special;
 257   1      
 258   1          for(line = 0; line < 30; line++) {
 259   2              bank = dmpcfgupddata[datacounts++];
 260   2              offset = dmpcfgupddata[datacounts++];
 261   2              bytes2write = dmpcfgupddata[datacounts++];
 262   2              MPU_Write_Byte(0x6d, bank);
 263   2              MPU_Write_Byte(0x6e, offset);
 264   2              MPU_Write_Len(0x6f, bytes2write, dmpcfgupddata + datacounts);
 265   2              writingcounts = bytes2write;
 266   2              datacounts += bytes2write;
 267   2              if(0 == bytes2write) {
 268   3                  special = dmpcfgupddata[datacounts++];
 269   3                  if(0x01 == special) {
 270   4                      //设置零运动中断启用（真）;
 271   4                      //设置FIFO缓冲区溢出启用（真）;
 272   4                      //设置DMP启用（真）;
 273   4                      MPU_Write_Byte(MPU_INT_EN_REG, 0x32);
 274   4                  } else
 275   3                      return 0;
 276   3              }
 277   2          }
 278   1          return 1;
 279   1      }
 280          
 281          /*最后更新DMP*/
 282          uint8_t xdmpUpdates(uint8_t datacounts)
 283          {
 284   1          uint8_t writingcounts, bank, offset, bytes2write;
 285   1          bank = dmpUpdates[datacounts++];
 286   1          offset = dmpUpdates[datacounts++];
 287   1          bytes2write = dmpUpdates[datacounts++];
 288   1          MPU_Write_Byte(0x6d, bank);
 289   1          MPU_Write_Byte(0x6e, offset);
 290   1          MPU_Write_Len(0x6f, bytes2write, dmpUpdates + datacounts);
 291   1          writingcounts = bytes2write;
 292   1          datacounts += bytes2write;
 293   1          return 1;
 294   1      }
 295          
 296          /*读取 FIFO 计数*/
 297          uint16_t getFIFOCount()
 298          {
 299   1          uint8_t i[2];
 300   1          MPU_Read_Len(MPU_FIFO_CNTH_REG, 2, i);
 301   1          return ((i[0] << 8) + i[1]);
 302   1      }
C51 COMPILER V9.60.7.0   DMP                                                               12/06/2024 10:38:26 PAGE 6   

 303          
 304          /*FIFO数据读取
 305          参数 *Data      存储数据的地址
 306          返回值 (1=读取成功,0读取失败)
 307          */
 308          uint8_t readdmp(uint8_t* Data)
 309          {
 310   1          return !MPU_Read_Len(MPU_FIFO_RW_REG, 42, Data);
 311   1      }
 312          
 313          //加载并配置 DMP 数字运动处理引擎
 314          uint8_t dmpInitialize(void)
 315          {
 316   1          uint8_t hwRevision, otpValid, mpuIntStatus/*fifoBuffer[128]*/;
 317   1          uint8_t xgOffsetTC, ygOffsetTC, zgOffsetTC;
 318   1          uint16_t fifoCount;
 319   1          MPU_Write_Bit(MPU_PWR_MGMT1_REG, 7, 1);     //复位 MPU6050
 320   1          MPU_Delay_Ms(30);
 321   1          MPU_Write_Bit(MPU_PWR_MGMT1_REG, 6, 0);     //禁止睡眠模式
 322   1          MPU_Write_Byte(0x6D, 0x70); //写入一个字节数据到0x6d寄存器(选择用户 bank)
 323   1          MPU_Write_Byte(0x6E, 0x06); //写入一个字节数据到0x6e寄存器(选择存储字节)
 324   1          MPU_Read_Len(0x6F, 1, &hwRevision); //读取
 325   1          MPU_Write_Byte(0x6D, 0);    //重置内存 bank 选择
 326   1          MPU_Read_Bit(0x00, 0, &otpValid);   //读取 OTP bank 有效标志
 327   1          MPU_Read_Bits(0x00, 6, 6, &xgOffsetTC);     //读陀螺偏置TC值 X
 328   1          MPU_Read_Bits(0x01, 6, 6, &ygOffsetTC);     //读陀螺偏置TC值 Y)
 329   1          MPU_Read_Bits(0x02, 6, 6, &zgOffsetTC);     //读陀螺偏置TC值 Z
 330   1          //MPU_Write_Byte(MPU_I2CSLV0_ADDR_REG,0x7f);        //设置从0地址 0x7
 331   1          //MPU_Write_Bit(MPU_USER_CTRL_REG,5,0);     //禁用I2C主模式
 332   1          //MPU_Write_Byte(MPU_I2CSLV0_ADDR_REG,0x68);        //这里可能要改。还没有弄明白这里
 333   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 1, 1);     //I2C总线主控复位
 334   1          MPU_Delay_Ms(20);
 335   1          if((loadfirmware()) == 0)
 336   1              return 0;       //加载
 337   1          if((loadcfgupd()) == 0)
 338   1              return 0;       //配置DMP
 339   1          MPU_Write_Bits(MPU_PWR_MGMT1_REG, 2, 3, 0x03);      //设置时钟脉冲源Z陀螺
 340   1          MPU_Write_Byte(MPU_INT_EN_REG, 0x12);       //设置DMP和FIFO_OFLOW启用中断
 341   1          MPU_Write_Byte(MPU_SAMPLE_RATE_REG, 4);     //设置采样率为200 hz  (1khz / (1 + 4) = 200 Hz)
 342   1          MPU_Write_Bits(MPU_CFG_REG, 5, 3, 0x1);     //设置外部帧同步TEMP_OUT_L[0]
 343   1          MPU_Write_Bits(MPU_CFG_REG, 2, 3, 0x03);    //设置DLPF带宽42赫兹
 344   1          MPU_Write_Bits(MPU_GYRO_CFG_REG, 4, 2, 0x03);       //陀螺灵敏度设置为+ / - 2000 deg/sec
 345   1          MPU_Write_Byte(0x70, 0x03); //设置DMP配置字节（功能未知）
 346   1          MPU_Write_Byte(0x71, 0x00); //设置DMP配置字节（功能未知）
 347   1          MPU_Write_Bit(0x00, 0, 0);  //清除OTP Bank 标志
 348   1          MPU_Write_Bits(0x00, 6, 6, 0);      //设置X 陀螺抵消TCs之前的值
 349   1          MPU_Write_Bits(0x01, 6, 6, 0);      //设置Y 陀螺抵消TCs之前的值
 350   1          MPU_Write_Bits(0x02, 6, 6, 0);      //设置Z 陀螺抵消TCs之前的值
 351   1          if(xdmpUpdates(0) == 0)
 352   1              return 0;       //最后更新1/7(函数未知)dmpUpdates数组第一行
 353   1          if(xdmpUpdates(5) == 0)
 354   1              return 0;       //最后更新2/7(函数未知)dmpUpdates数组第二行
 355   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1);     //复位 FIFO
 356   1          fifoCount = getFIFOCount(); //读取 FIFO 计数
 357   1          //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据
 358   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1);     //复位 FIFO
 359   1      
 360   1          MPU_Write_Byte(MPU_MOTION_DET_REG, 2);      //运动检测阈值设置为2
 361   1          MPU_Write_Byte(0x21, 156);  //零运动检测阈值为156
 362   1          MPU_Write_Byte(0x20, 80);   //设置运动检测持续时间至80
 363   1          MPU_Write_Byte(0x22, 0);    //设置零运动检测时间0
 364   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1);     //复 位 FIFO
C51 COMPILER V9.60.7.0   DMP                                                               12/06/2024 10:38:26 PAGE 7   

 365   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 6, 1);     //使能 FIFO
 366   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 7, 1);     //使能 DMP
 367   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 3, 1);     //复位 DMP
 368   1          if(xdmpUpdates(12) == 0)
 369   1              return 0;       //最后更新3/7(函数未知)dmpUpdates数组第三行
 370   1          if(xdmpUpdates(17) == 0)
 371   1              return 0;       //最后更新4/7(函数未知)dmpUpdates数组第四行
 372   1          if(xdmpUpdates(28) == 0)
 373   1              return 0;       //最后更新5/7(函数未知)dmpUpdates数组第五行
 374   1          while((fifoCount = getFIFOCount()) < 3);    //等待 FIFO 计数 > 2
 375   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1);                     //复位 FIFO
 376   1          //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据
 377   1          MPU_Read_Len(MPU_INT_STA_REG, 1, &mpuIntStatus);            //读取中断状态
 378   1          if(xdmpUpdates(35) == 0)
 379   1              return 0;       //最后更新6/7(函数未知)dmpUpdates数组第六行
 380   1          while((fifoCount = getFIFOCount()) < 3);    //等待 FIFO 计数 > 2
 381   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1);     //复位 FIFO
 382   1          //readdmp(fifoCount,fifoBuffer);    //读取FIFO里的数据
 383   1          MPU_Read_Len(MPU_INT_STA_REG, 1, &mpuIntStatus);    //读取中断状态
 384   1          if(xdmpUpdates(40) == 0)
 385   1              return 0;       //最后更新7/7(函数未知)dmpUpdates数组第七行
 386   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 7, 0);     //禁用DMP(稍后您打开它)
 387   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1);     //复位 FIFO
 388   1          MPU_Read_Len(MPU_INT_STA_REG, 1, &mpuIntStatus);
 389   1          //星期六 (2014/06/28)
 390   1          return 1;
 391   1      }
 392          
 393          /*初始化MPU6050*/
 394          void initMPU6050(void)
 395          {
 396   1          MPU_Write_Bits(MPU_PWR_MGMT1_REG, 2, 3, 0x01);      //电源管理
 397   1          MPU_Write_Bits(MPU_GYRO_CFG_REG, 4, 2, 0x00);       //设置陀螺仪量程 250/s
 398   1          MPU_Write_Bits(MPU_ACCEL_CFG_REG, 4, 2, 0x00);      //设置加速度量程 2G
 399   1          MPU_Write_Bit(MPU_PWR_MGMT1_REG, 6, 1);     //电源管理MUP进入睡眠模式
 400   1      }
 401          
 402          /*验证MPU6050连接*/
 403          uint8_t getDeviceID(void)
 404          {
 405   1          uint8_t b = 0;      //临时变量
 406   1          MPU_Read_Bits(MPU_DEVICE_ID_REG, 6, 6, &b); //读取i2c固定地址，去掉最高位和最低位这两位数据
 407   1          return b == 0x34;   //判断B是否等于0x34，如果等于返回1，不等于返回0(库的是0x38)
 408   1      
 409   1      }
 410          
 411          void MPU6050_DMP_Init(void)
 412          {
 413   1          initMPU6050();      //初始化
 414   1          if(getDeviceID())   //验证连接是否正常(读取MPU6050的I2C地址)
 415   1              while(!(dmpInitialize()));      //加载并配置运动库
 416   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1);     //复位 FIFO
 417   1          MPU_Write_Bit(MPU_USER_CTRL_REG, 7, 1);     //使能DMP
 418   1      }
 419          
 420          void MPU6050_Refresh_DMP(void)
 421          {
 422   1          static uint8_t zd;
 423   1          static uint16_t i;
 424   1          i = getFIFOCount();//读取FIFO计数
 425   1          MPU_Read_Len(MPU_INT_STA_REG, 1, &zd);      //读取中断状态
 426   1          if((zd & 0x10) || i >= 840) {       //判断FIFO是否溢出
C51 COMPILER V9.60.7.0   DMP                                                               12/06/2024 10:38:26 PAGE 8   

 427   2              MPU_Write_Bit(MPU_USER_CTRL_REG, 2, 1); //复位 FIFO
 428   2          } else if(zd & 0x02) {
 429   2              while(i < 42)
 430   2                  i = getFIFOCount();
 431   2              if(readdmp(dmpdatas)) { //读取FIFO数据
 432   3                  Q[0] = ((int16_t)dmpdatas[0] << 8 | dmpdatas[1]) / 16384.;
 433   3                  Q[1] = ((int16_t)dmpdatas[4] << 8 | dmpdatas[5]) / 16384.;
 434   3                  Q[2] = ((int16_t)dmpdatas[8] << 8 | dmpdatas[9]) / 16384.;
 435   3                  Q[3] = ((int16_t)dmpdatas[12] << 8 | dmpdatas[13]) / 16384.;
 436   3              }
 437   2          }
 438   1      }
 439          


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =   1433    ----
   CONSTANT SIZE    =   2168    ----
   XDATA SIZE       =     61      26
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----    ----
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  0 WARNING(S),  0 ERROR(S)
