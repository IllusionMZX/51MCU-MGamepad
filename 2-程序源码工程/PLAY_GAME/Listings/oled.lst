C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 1   


C51 COMPILER V9.60.7.0, COMPILATION OF MODULE OLED
OBJECT MODULE PLACED IN .\Objects\oled.obj
COMPILER INVOKED BY: E:\Program Files\Keil_v5\Keil_arm\C51\BIN\C51.EXE oled.c LARGE OPTIMIZE(8,SPEED) BROWSE DEBUG OBJEC
                    -TEXTEND PRINT(.\Listings\oled.lst) OBJECT(.\Objects\oled.obj)

line level    source

   1          #include "OLED.h"
   2          #include <string.h>
   3          #include <math.h>
   4          #include <stdio.h>
   5          #include <intrins.h>
   6          /**
   7            * 数据存储格式：
   8            * 纵向8点，高位在下，先从左到右，再从上到下
   9            * 每一个Bit对应一个像素点
  10            *
  11            *      B0 B0                  B0 B0
  12            *      B1 B1                  B1 B1
  13            *      B2 B2                  B2 B2
  14            *      B3 B3  ------------->  B3 B3 --
  15            *      B4 B4                  B4 B4  |
  16            *      B5 B5                  B5 B5  |
  17            *      B6 B6                  B6 B6  |
  18            *      B7 B7                  B7 B7  |
  19            *                                    |
  20            *  -----------------------------------
  21            *  |
  22            *  |   B0 B0                  B0 B0
  23            *  |   B1 B1                  B1 B1
  24            *  |   B2 B2                  B2 B2
  25            *  --> B3 B3  ------------->  B3 B3
  26            *      B4 B4                  B4 B4
  27            *      B5 B5                  B5 B5
  28            *      B6 B6                  B6 B6
  29            *      B7 B7                  B7 B7
  30            *
  31            * 坐标轴定义：
  32            * 左上角为(0, 0)点
  33            * 横向向右为X轴，取值范围：0~127
  34            * 纵向向下为Y轴，取值范围：0~63
  35            *
  36            *       0             X轴           127
  37            *      .------------------------------->
  38            *    0 |
  39            *      |
  40            *      |
  41            *      |
  42            *  Y轴 |
  43            *      |
  44            *      |
  45            *      |
  46            *   63 |
  47            *      v
  48            *
  49            */
  50          
  51          
  52          
  53          
  54          sbit sda = P0 ^ 3; // SDA接口
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 2   

  55          sbit scl = P0 ^ 2; // SCL接口
  56          
  57          /************星球大战部分*************/
  58          
  59          /**
  60            * OLED显存数组
  61            * 所有的显示函数，都只是对此显存数组进行读写
  62            * 随后调用OLED_Update函数或OLED_UpdateArea函数
  63            * 才会将显存数组的数据发送到OLED硬件，进行显示
  64            */
  65          uint8_t OLED_DisplayBuf[8][128] = {
  66              0x00, 0x00, 0x7E, 0x00, 0x40, 0x00, 0x3C, 0x42, 0x42, 0x3C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
  67              0xC0, 0xC0, 0x60, 0x20, 0x30, 0x10, 0x18, 0x18, 0x0C, 0x7F, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
  68              0x03, 0x7F, 0x08, 0x18, 0x18, 0x10, 0x30, 0x30, 0x60, 0xC0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00,
  69              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xE0, 0xE0,
  70              0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x30, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
  71              0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0xE0, 0xF0, 0xF0, 0xF0, 0xF0,
  72              0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0,
  73              0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  74              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF0, 0x1C, 0x0E, 0x03, 0x01,
  75              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  76              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x0E, 0x1C, 0xF0,
  77              0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x3F,
  78              0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xC7, 0x87, 0x00, 0x00, 0x07, 0x07, 0x07, 0xFF, 0xFF, 0xFF,
  79              0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x07, 0x07, 0x07, 0x00, 0x80, 0xFC, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF,
  80              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
  81              0xC7, 0xE7, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  82              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xFE, 0xFF, 0xF8, 0xF0, 0x00, 0x00, 0x00,
  83              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  84              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xF8,
  85              0xFF, 0xFC, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1C,
  86              0x1C, 0x1C, 0x1F, 0x1F, 0x1F, 0x0F, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x1F, 0x1F,
  87              0x1F, 0x1F, 0x1F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x18, 0x1F, 0x1F, 0x1F, 0x1F, 0x1E, 0x1E, 0x0F,
  88              0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1C, 0x00, 0x07, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F,
  89              0x07, 0x0F, 0x1F, 0x3F, 0x3F, 0x1E, 0x0C, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  90              0x00, 0x00, 0x00, 0x00, 0x00, 0x78, 0xFE, 0x07, 0x01, 0x00, 0x01, 0x03, 0x07, 0xC6, 0xF4, 0xF4,
  91              0xE4, 0xE4, 0xEC, 0xE8, 0xE8, 0xE8, 0xC8, 0xC8, 0xC8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8, 0xD8,
  92              0xD8, 0xD8, 0xC8, 0xE8, 0xE8, 0xE8, 0xE8, 0xE8, 0xEC, 0xE4, 0xE4, 0xE4, 0xF6, 0x46, 0x03, 0x03,
  93              0x01, 0x00, 0x01, 0x83, 0xFE, 0x78, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x1F,
  94              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x8F, 0x00, 0x00, 0xCF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x8F, 0x00,
  95              0x00, 0xCF, 0xFF, 0xFF, 0xFF, 0x1F, 0x0F, 0x00, 0x80, 0xC0, 0xC0, 0xE0, 0xE0, 0x60, 0x60, 0x60,
  96              0xE0, 0xE0, 0xE0, 0xC0, 0xC0, 0x80, 0x00, 0x00, 0x00, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0xE0, 0x80,
  97              0xC0, 0xC0, 0xE0, 0xE0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
  98              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0xFE, 0x1C, 0x00, 0x00, 0x08, 0x11, 0x27, 0x43,
  99              0x83, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1F, 0xFF, 0xFF, 0xFF, 0x0F,
 100              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x83, 0x43, 0x27, 0x10, 0x08, 0x00,
 101              0x00, 0x3C, 0xFE, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 102              0x00, 0x03, 0x1F, 0xFF, 0xFF, 0xFF, 0xFC, 0xFE, 0x7F, 0x1F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xFC,
 103              0xFE, 0xFF, 0x1F, 0x03, 0x00, 0x00, 0x00, 0x00, 0x38, 0x7C, 0xFE, 0xFE, 0xFE, 0xEE, 0xC6, 0x46,
 104              0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE0, 0x00, 0x00, 0xE0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
 105              0xE7, 0x03, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 106              0x00, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0x3C, 0x07, 0x33, 0x78, 0x70, 0x68, 0x10, 0x20, 0x20, 0x40,
 107              0x41, 0x32, 0x08, 0x40, 0x40, 0x20, 0x30, 0x10, 0x18, 0x18, 0x0C, 0x0C, 0x0F, 0x0F, 0x0F, 0x0C,
 108              0x1C, 0x18, 0x18, 0x30, 0x20, 0x20, 0x40, 0x40, 0x1C, 0x23, 0x41, 0x40, 0x20, 0x30, 0x10, 0x28,
 109              0x70, 0x78, 0x37, 0x0F, 0x3C, 0xF0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 110              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 111              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 112              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 113              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 114              0x00, 0x00, 0x00, 0x00, 0x03, 0x0F, 0x38, 0x30, 0x60, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00,
 115              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0xC0, 0xE0, 0xE0, 0xE0, 0xC0,
 116              0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 3   

 117              0xC0, 0xC0, 0x60, 0x30, 0x1C, 0x0F, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 118              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0x00, 0x00,
 119              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0x78, 0xF8, 0x80, 0x00, 0x00,
 120              0x00, 0x80, 0xF0, 0x78, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0xC0, 0xF0, 0x70, 0x38, 0x18, 0x18, 0x08,
 121              0x08, 0x00, 0x00, 0x00, 0xF8, 0xF8, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00,
 122              0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x0C, 0x18, 0x30, 0x30,
 123              0x60, 0x66, 0x4F, 0x4F, 0x5F, 0x5F, 0x4F, 0x4F, 0x63, 0x60, 0x30, 0x1C, 0x0C, 0x05, 0x04, 0x1C,
 124              0x30, 0x60, 0x67, 0x4F, 0x4F, 0x4F, 0x5F, 0x4F, 0x4F, 0x66, 0x60, 0x30, 0x30, 0x18, 0x0C, 0x07,
 125              0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 126              0x00, 0x00, 0x00, 0x30, 0x30, 0x38, 0x1F, 0x0F, 0x07, 0x00, 0x00, 0x3F, 0x3F, 0x3F, 0x30, 0x30,
 127              0x30, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3F, 0x3F, 0x00, 0x01, 0x1F, 0x3E, 0x3C,
 128              0x3E, 0x0F, 0x01, 0x00, 0x3F, 0x3F, 0x00, 0x00, 0x00, 0x07, 0x1F, 0x1C, 0x38, 0x30, 0x30, 0x30,
 129              0x30, 0x00, 0x00, 0x00, 0x0F, 0x1F, 0x3F, 0x30, 0x30, 0x30, 0x30, 0x38, 0x0F, 0x00, 0x00, 0x00,
 130          };
 131          
 132          /**
 133            * 函    数：OLED写SCL高低电平
 134            * 参    数：要写入SCL的电平值，范围：0/1
 135            * 返 回 值：无
 136            * 说    明：当上层函数需要写SCL时，此函数会被调用
 137            *           用户需要根据参数传入的值，将SCL置为高电平或者低电平
 138            *           当参数传入0时，置SCL为低电平，当参数传入1时，置SCL为高电平
 139            */
 140          void OLED_W_SCL(uint8_t BitValue)
 141          {
 142   1          /*根据BitValue的值，将SCL置高电平或者低电平*/
 143   1          if(BitValue) scl = 1;
 144   1          else scl = 0;
 145   1      }
 146          
 147          /**
 148            * 函    数：OLED写SDA高低电平
 149            * 参    数：要写入SDA的电平值，范围：0/1
 150            * 返 回 值：无
 151            * 说    明：当上层函数需要写SDA时，此函数会被调用
 152            *           用户需要根据参数传入的值，将SDA置为高电平或者低电平
 153            *           当参数传入0时，置SDA为低电平，当参数传入1时，置SDA为高电平
 154            */
 155          void OLED_W_SDA(uint8_t BitValue)
 156          {
 157   1          /*根据BitValue的值，将SDA置高电平或者低电平*/
 158   1          if(BitValue) sda = 1;
 159   1          else sda = 0;
 160   1      }
 161          
 162          /**
 163            * 函    数：OLED引脚初始化
 164            * 参    数：无
 165            * 返 回 值：无
 166            * 说    明：当上层函数需要初始化时，此函数会被调用
 167            *           用户需要将SCL和SDA引脚初始化为开漏模式，并释放引脚
 168            */
 169          void OLED_GPIO_Init(void)
 170          {
 171   1          /*在初始化前，加入适量延时，待OLED供电稳定*/
 172   1          unsigned char data i, j, k;
 173   1      
 174   1          i = 22;
 175   1          j = 3;
 176   1          k = 227;
 177   1          do {
 178   2              do {
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 4   

 179   3                  while(--k);
 180   3              } while(--j);
 181   2          } while(--i);
 182   1      
 183   1          /*释放SCL和SDA*/
 184   1          OLED_W_SCL(1);
 185   1          OLED_W_SDA(1);
 186   1      }
 187          
 188          
 189          /**
 190            * 函    数：I2C起始
 191            * 参    数：无
 192            * 返 回 值：无
 193            */
 194          void OLED_I2C_Start(void)
 195          {
 196   1          OLED_W_SDA(1);              //释放SDA，确保SDA为高电平
 197   1          OLED_W_SCL(1);              //释放SCL，确保SCL为高电平
 198   1          OLED_W_SDA(0);              //在SCL高电平期间，拉低SDA，产生起始信号
 199   1          OLED_W_SCL(0);              //起始后把SCL也拉低，即为了占用总线，也为了方便总线时序的拼
             -接
 200   1      }
 201          
 202          /**
 203            * 函    数：I2C终止
 204            * 参    数：无
 205            * 返 回 值：无
 206            */
 207          void OLED_I2C_Stop(void)
 208          {
 209   1          OLED_W_SDA(0);              //拉低SDA，确保SDA为低电平
 210   1          OLED_W_SCL(1);              //释放SCL，使SCL呈现高电平
 211   1          OLED_W_SDA(1);              //在SCL高电平期间，释放SDA，产生终止信号
 212   1      }
 213          
 214          
 215          /**
 216            * 函    数：I2C发送一个字节
 217            * 参    数：Byte 要发送的一个字节数据，范围：0x00~0xFF
 218            * 返 回 值：无
 219            */
 220          void OLED_I2C_SendByte(uint8_t Byte)
 221          {
 222   1          uint8_t i;
 223   1      
 224   1          /*循环8次，主机依次发送数据的每一位*/
 225   1          for(i = 0; i < 8; i++) {
 226   2              /*使用掩码的方式取出Byte的指定一位数据并写入到SDA线*/
 227   2              /*两个!的作用是，让所有非零的值变为1*/
 228   2              OLED_W_SDA(!!(Byte & (0x80 >> i)));
 229   2              OLED_W_SCL(1);  //释放SCL，从机在SCL高电平期间读取SDA
 230   2              OLED_W_SCL(0);  //拉低SCL，主机开始发送下一位数据
 231   2          }
 232   1      
 233   1          OLED_W_SCL(1);              //额外的一个时钟，不处理应答信号
 234   1          OLED_W_SCL(0);
 235   1      }
 236          
 237          /**
 238            * 函    数：OLED写命令
 239            * 参    数：Command 要写入的命令值，范围：0x00~0xFF
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 5   

 240            * 返 回 值：无
 241            */
 242          void OLED_WriteCommand(uint8_t Command)
 243          {
 244   1          OLED_I2C_Start();                           //I2C起始
 245   1          OLED_I2C_SendByte(0x78);            //发送OLED的I2C从机地址
 246   1          OLED_I2C_SendByte(0x00);            //控制字节，给0x00，表示即将写命令
 247   1          OLED_I2C_SendByte(Command);         //写入指定的命令
 248   1          OLED_I2C_Stop();                            //I2C终止
 249   1      }
 250          
 251          /**
 252            * 函    数：OLED写数据
 253            * 参    数：Data 要写入数据的起始地址
 254            * 参    数：Count 要写入数据的数量
 255            * 返 回 值：无
 256            */
 257          void OLED_WriteData(uint8_t* Data, uint8_t Count)
 258          {
 259   1          uint8_t i;
 260   1      
 261   1          OLED_I2C_Start();                           //I2C起始
 262   1          OLED_I2C_SendByte(0x78);            //发送OLED的I2C从机地址
 263   1          OLED_I2C_SendByte(0x40);            //控制字节，给0x40，表示即将写数据
 264   1          /*循环Count次，进行连续的数据写入*/
 265   1          for(i = 0; i < Count; i ++) {
 266   2              OLED_I2C_SendByte(Data[i]);     //依次发送Data的每一个数据
 267   2          }
 268   1          OLED_I2C_Stop();                            //I2C终止
 269   1      }
 270          
 271          /**
 272            * 函    数：OLED初始化
 273            * 参    数：无
 274            * 返 回 值：无
 275            * 说    明：使用前，需要调用此初始化函数
 276            */
 277          void OLED_Init(void)
 278          {
 279   1          OLED_GPIO_Init();                   //先调用底层的端口初始化
 280   1      
 281   1          /*写入一系列的命令，对OLED进行初始化配置*/
 282   1          OLED_WriteCommand(0xAE);    //设置显示开启/关闭，0xAE关闭，0xAF开启
 283   1      
 284   1          OLED_WriteCommand(0xD5);    //设置显示时钟分频比/振荡器频率
 285   1          OLED_WriteCommand(0x80);    //0x00~0xFF
 286   1      
 287   1          OLED_WriteCommand(0xA8);    //设置多路复用率
 288   1          OLED_WriteCommand(0x3F);    //0x0E~0x3F
 289   1      
 290   1          OLED_WriteCommand(0xD3);    //设置显示偏移
 291   1          OLED_WriteCommand(0x00);    //0x00~0x7F
 292   1      
 293   1          OLED_WriteCommand(0x40);    //设置显示开始行，0x40~0x7F
 294   1      
 295   1          OLED_WriteCommand(0xA1);    //设置左右方向，0xA1正常，0xA0左右反置
 296   1      
 297   1          OLED_WriteCommand(0xC8);    //设置上下方向，0xC8正常，0xC0上下反置
 298   1      
 299   1          OLED_WriteCommand(0xDA);    //设置COM引脚硬件配置
 300   1          OLED_WriteCommand(0x12);
 301   1      
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 6   

 302   1          OLED_WriteCommand(0x81);    //设置对比度
 303   1          OLED_WriteCommand(0xCF);    //0x00~0xFF
 304   1      
 305   1          OLED_WriteCommand(0xD9);    //设置预充电周期
 306   1          OLED_WriteCommand(0xF1);
 307   1      
 308   1          OLED_WriteCommand(0xDB);    //设置VCOMH取消选择级别
 309   1          OLED_WriteCommand(0x30);
 310   1      
 311   1          OLED_WriteCommand(0xA4);    //设置整个显示打开/关闭
 312   1      
 313   1          OLED_WriteCommand(0xA6);    //设置正常/反色显示，0xA6正常，0xA7反色
 314   1      
 315   1          OLED_WriteCommand(0x8D);    //设置充电泵
 316   1          OLED_WriteCommand(0x14);
 317   1      
 318   1          OLED_WriteCommand(0xAF);    //开启显示
 319   1      
 320   1          OLED_Clear();                               //清空显存数组
 321   1          OLED_Update();                              //更新显示，清屏，防止初始化后未显示内容时花屏
 322   1      }
 323          
 324          /**
 325            * 函    数：OLED设置显示光标位置
 326            * 参    数：Page 指定光标所在的页，范围：0~7
 327            * 参    数：X 指定光标所在的X轴坐标，范围：0~127
 328            * 返 回 值：无
 329            * 说    明：OLED默认的Y轴，只能8个Bit为一组写入，即1页等于8个Y轴坐标
 330            */
 331          void OLED_SetCursor(uint8_t Page, uint8_t X)
 332          {
 333   1          /*如果使用此程序驱动1.3寸的OLED显示屏，则需要解除此注释*/
 334   1          /*因为1.3寸的OLED驱动芯片（SH1106）有132列*/
 335   1          /*屏幕的起始列接在了第2列，而不是第0列*/
 336   1          /*所以需要将X加2，才能正常显示*/
 337   1      //      X += 2;
 338   1      
 339   1          /*通过指令设置页地址和列地址*/
 340   1          OLED_WriteCommand(0xB0 | Page);                                     //设置页位置
 341   1          OLED_WriteCommand(0x10 | ((X & 0xF0) >> 4));        //设置X位置高4位
 342   1          OLED_WriteCommand(0x00 | (X & 0x0F));                       //设置X位置低4位
 343   1      }
 344          
 345          
 346          
 347          /*工具函数*********************/
 348          
 349          /*工具函数仅供内部部分函数使用*/
 350          
 351          /**
 352            * 函    数：次方函数
 353            * 参    数：X 底数
 354            * 参    数：Y 指数
 355            * 返 回 值：等于X的Y次方
 356            */
 357          uint32_t OLED_Pow(uint32_t X, uint32_t Y)
 358          {
 359   1          uint32_t Result = 1;        //结果默认为1
 360   1          while(Y --) {               //累乘Y次
 361   2              Result *= X;            //每次把X累乘到结果上
 362   2          }
 363   1          return Result;
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 7   

 364   1      }
 365          
 366          /**
 367            * 函    数：判断指定点是否在指定多边形内部
 368            * 参    数：nvert 多边形的顶点数
 369            * 参    数：vertx verty 包含多边形顶点的x和y坐标的数组
 370            * 参    数：testx testy 测试点的X和y坐标
 371            * 返 回 值：指定点是否在指定多边形内部，1：在内部，0：不在内部
 372            */
 373          uint8_t OLED_pnpoly(uint8_t nvert, int* vertx, int* verty, int testx, int testy)
 374          {
 375   1          int i, j, c = 0;
 376   1          for(i = 0, j = nvert - 1; i < nvert; j = i++) {
 377   2              if(((verty[i] > testy) != (verty[j] > testy)) &&
 378   2                      (testx < (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i])) {
 379   3                  c = !c;
 380   3              }
 381   2          }
 382   1          return c;
 383   1      }
 384          
 385          /**
 386            * 函    数：判断指定点是否在指定角度内部
 387            * 参    数：X Y 指定点的坐标
 388            * 参    数：StartAngle EndAngle 起始角度和终止角度，范围：-180~180
 389            *           水平向右为0度，水平向左为180度或-180度，下方为正数，上方为负数，
             -顺时针旋转
 390            * 返 回 值：指定点是否在指定角度内部，1：在内部，0：不在内部
 391            */
 392          uint8_t OLED_IsInAngle(int X, int Y, int StartAngle, int EndAngle)
 393          {
 394   1          int PointAngle;
 395   1          PointAngle = atan2(Y, X) / 3.14 * 180;
 396   1          if(StartAngle < EndAngle) {
 397   2              if(PointAngle >= StartAngle && PointAngle <= EndAngle) {
 398   3                  return 1;
 399   3              }
 400   2          } else {
 401   2              if(PointAngle >= StartAngle || PointAngle <= EndAngle) {
 402   3                  return 1;
 403   3              }
 404   2          }
 405   1          return 0;
 406   1      }
 407          
 408          /*********************工具函数*/
 409          
 410          
 411          /*功能函数*********************/
 412          
 413          /**
 414            * 函    数：将OLED显存数组更新到OLED屏幕
 415            * 参    数：无
 416            * 返 回 值：无
 417            * 说    明：所有的显示函数，都只是对OLED显存数组进行读写
 418            *           随后调用OLED_Update函数或OLED_UpdateArea函数
 419            *           才会将显存数组的数据发送到OLED硬件，进行显示
 420            *           故调用显示函数后，要想真正地呈现在屏幕上，还需调用更新函数
 421            */
 422          void OLED_Update(void)
 423          {
 424   1          uint8_t j;
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 8   

 425   1          for(j = 0; j < 8; j ++) {
 426   2              OLED_SetCursor(j, 0);
 427   2              OLED_WriteData(OLED_DisplayBuf[j], 128);
 428   2          }
 429   1      }
 430          
 431          /**
 432            * 函    数：将OLED显存数组部分更新到OLED屏幕
 433            * 参    数：X 指定区域左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 434            * 参    数：Y 指定区域左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 435            * 参    数：Width 指定区域的宽度，范围：0~128
 436            * 参    数：Height 指定区域的高度，范围：0~64
 437            * 返 回 值：无
 438            * 说    明：此函数会至少更新参数指定的区域
 439            *           如果更新区域Y轴只包含部分页，则同一页的剩余部分会跟随一起更新
 440            * 说    明：所有的显示函数，都只是对OLED显存数组进行读写
 441            *           随后调用OLED_Update函数或OLED_UpdateArea函数
 442            *           才会将显存数组的数据发送到OLED硬件，进行显示
 443            *           故调用显示函数后，要想真正地呈现在屏幕上，还需调用更新函数
 444            */
 445          void OLED_UpdateArea(int X, int Y, uint8_t Width, uint8_t Height)
 446          {
 447   1          int j;
 448   1          int Page, Page1;
 449   1          Page = Y / 8;
 450   1          Page1 = (Y + Height - 1) / 8 + 1;
 451   1          if(Y < 0) {
 452   2              Page -= 1;
 453   2              Page1 -= 1;
 454   2          }
 455   1      
 456   1          for(j = Page; j < Page1; j ++) {
 457   2              if(X >= 0 && X <= 127 && j >= 0 && j <= 7) {
 458   3                  OLED_SetCursor(j, X);
 459   3                  OLED_WriteData(&OLED_DisplayBuf[j][X], Width);
 460   3              }
 461   2          }
 462   1      }
 463          
 464          /**
 465            * 函    数：将OLED显存数组全部清零
 466            * 参    数：无
 467            * 返 回 值：无
 468            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 469            */
 470          void OLED_Clear(void)
 471          {
 472   1          uint8_t i, j;
 473   1          for(j = 0; j < 8; j ++) {
 474   2              for(i = 0; i < 128; i ++) {
 475   3                  OLED_DisplayBuf[j][i] = 0x00;
 476   3              }
 477   2          }
 478   1      }
 479          
 480          /**
 481            * 函    数：将OLED显存数组部分清零
 482            * 参    数：X 指定区域左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 483            * 参    数：Y 指定区域左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 484            * 参    数：Width 指定区域的宽度，范围：0~128
 485            * 参    数：Height 指定区域的高度，范围：0~64
 486            * 返 回 值：无
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 9   

 487            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 488            */
 489          void OLED_ClearArea(int X, int Y, uint8_t Width, uint8_t Height)
 490          {
 491   1          int i, j;
 492   1      
 493   1          for(j = Y; j < Y + Height; j ++) {
 494   2              for(i = X; i < X + Width; i ++) {
 495   3                  if(i >= 0 && i <= 127 && j >= 0 && j <= 63) {
 496   4                      OLED_DisplayBuf[j / 8][i] &= ~(0x01 << (j % 8));
 497   4                  }
 498   3              }
 499   2          }
 500   1      }
 501          
 502          /**
 503            * 函    数：将OLED显存数组全部取反
 504            * 参    数：无
 505            * 返 回 值：无
 506            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 507            */
 508          void OLED_Reverse(void)
 509          {
 510   1          uint8_t i, j;
 511   1          for(j = 0; j < 8; j ++) {
 512   2              for(i = 0; i < 128; i ++) {
 513   3                  OLED_DisplayBuf[j][i] ^= 0xFF;
 514   3              }
 515   2          }
 516   1      }
 517          
 518          /**
 519            * 函    数：将OLED显存数组部分取反
 520            * 参    数：X 指定区域左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 521            * 参    数：Y 指定区域左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 522            * 参    数：Width 指定区域的宽度，范围：0~128
 523            * 参    数：Height 指定区域的高度，范围：0~64
 524            * 返 回 值：无
 525            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 526            */
 527          void OLED_ReverseArea(int X, int Y, uint8_t Width, uint8_t Height)
 528          {
 529   1          int i, j;
 530   1      
 531   1          for(j = Y; j < Y + Height; j ++) {
 532   2              for(i = X; i < X + Width; i ++) {
 533   3                  if(i >= 0 && i <= 127 && j >= 0 && j <= 63) {
 534   4                      OLED_DisplayBuf[j / 8][i] ^= 0x01 << (j % 8);
 535   4                  }
 536   3              }
 537   2          }
 538   1      }
 539          
 540          /**
 541            * 函    数：OLED显示一个字符
 542            * 参    数：X 指定字符左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 543            * 参    数：Y 指定字符左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 544            * 参    数：Char 指定要显示的字符，范围：ASCII码可见字符
 545            * 参    数：FontSize 指定字体大小
 546            *           范围：OLED_8X16                宽8像素，高16像素
 547            *                 OLED_6X8            宽6像素，高8像素
 548            * 返 回 值：无
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 10  

 549            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 550            */
 551          void OLED_ShowChar(int X, int Y, char Char, uint8_t FontSize)
 552          {
 553   1          if(FontSize == OLED_8X16) { //字体为宽8像素，高16像素
 554   2              /*将ASCII字模库OLED_F8x16的指定数据以8*16的图像格式显示*/
 555   2              OLED_ShowImage(X, Y, 8, 16, OLED_F8x16[Char - ' ']);
 556   2          } else if(FontSize == OLED_6X8) {   //字体为宽6像素，高8像素
 557   2              /*将ASCII字模库OLED_F6x8的指定数据以6*8的图像格式显示*/
 558   2              OLED_ShowImage(X, Y, 6, 8, OLED_F6x8[Char - ' ']);
 559   2          }
 560   1      }
 561          
 562          /**
 563            * 函    数：OLED显示字符串
 564            * 参    数：X 指定字符串左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 565            * 参    数：Y 指定字符串左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 566            * 参    数：String 指定要显示的字符串，范围：ASCII码可见字符组成的字符串
 567            * 参    数：FontSize 指定字体大小
 568            *           范围：OLED_8X16                宽8像素，高16像素
 569            *                 OLED_6X8            宽6像素，高8像素
 570            * 返 回 值：无
 571            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 572            */
 573          void OLED_ShowString(int X, int Y, char* String, uint8_t FontSize)
 574          {
 575   1          uint8_t i;
 576   1          for(i = 0; String[i] != '\0'; i++) {        //遍历字符串的每个字符
 577   2              /*调用OLED_ShowChar函数，依次显示每个字符*/
 578   2              OLED_ShowChar(X + i * FontSize, Y, String[i], FontSize);
 579   2          }
 580   1      }
 581          
 582          /**
 583            * 函    数：OLED显示数字（十进制，正整数）
 584            * 参    数：X 指定数字左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 585            * 参    数：Y 指定数字左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 586            * 参    数：Number 指定要显示的数字，范围：0~4294967295
 587            * 参    数：Length 指定数字的长度，范围：0~10
 588            * 参    数：FontSize 指定字体大小
 589            *           范围：OLED_8X16                宽8像素，高16像素
 590            *                 OLED_6X8            宽6像素，高8像素
 591            * 返 回 值：无
 592            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 593            */
 594          void OLED_ShowNum(int X, int Y, uint32_t Number, uint8_t Length, uint8_t FontSize)
 595          {
 596   1          uint8_t i;
 597   1          for(i = 0; i < Length; i++) {       //遍历数字的每一位
 598   2              /*调用OLED_ShowChar函数，依次显示每个数字*/
 599   2              /*Number / OLED_Pow(10, Length - i - 1) % 10 可以十进制提取数字的每一位*/
 600   2              /*+ '0' 可将数字转换为字符格式*/
 601   2              OLED_ShowChar(X + i * FontSize, Y, Number / OLED_Pow(10, Length - i - 1) % 10 + '0', FontSize);
 602   2          }
 603   1      }
 604          
 605          /**
 606            * 函    数：OLED显示有符号数字（十进制，整数）
 607            * 参    数：X 指定数字左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 608            * 参    数：Y 指定数字左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 609            * 参    数：Number 指定要显示的数字，范围：-2147483648~2147483647
 610            * 参    数：Length 指定数字的长度，范围：0~10
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 11  

 611            * 参    数：FontSize 指定字体大小
 612            *           范围：OLED_8X16                宽8像素，高16像素
 613            *                 OLED_6X8            宽6像素，高8像素
 614            * 返 回 值：无
 615            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 616            */
 617          void OLED_ShowSignedNum(int X, int Y, int32_t Number, uint8_t Length, uint8_t FontSize)
 618          {
 619   1          uint8_t i;
 620   1          uint32_t Number1;
 621   1      
 622   1          if(Number >= 0) {                                   //数字大于等于0
 623   2              OLED_ShowChar(X, Y, '+', FontSize);     //显示+号
 624   2              Number1 = Number;                                       //Number1直接等于Number
 625   2          } else {                                                            //数字小于0
 626   2              OLED_ShowChar(X, Y, '-', FontSize);     //显示-号
 627   2              Number1 = -Number;                                      //Number1等于Number取负
 628   2          }
 629   1      
 630   1          for(i = 0; i < Length; i++) {               //遍历数字的每一位
 631   2              /*调用OLED_ShowChar函数，依次显示每个数字*/
 632   2              /*Number1 / OLED_Pow(10, Length - i - 1) % 10 可以十进制提取数字的每一位*/
 633   2              /*+ '0' 可将数字转换为字符格式*/
 634   2              OLED_ShowChar(X + (i + 1) * FontSize, Y, Number1 / OLED_Pow(10, Length - i - 1) % 10 + '0', FontSi
             -ze);
 635   2          }
 636   1      }
 637          
 638          /**
 639            * 函    数：OLED显示十六进制数字（十六进制，正整数）
 640            * 参    数：X 指定数字左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 641            * 参    数：Y 指定数字左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 642            * 参    数：Number 指定要显示的数字，范围：0x00000000~0xFFFFFFFF
 643            * 参    数：Length 指定数字的长度，范围：0~8
 644            * 参    数：FontSize 指定字体大小
 645            *           范围：OLED_8X16                宽8像素，高16像素
 646            *                 OLED_6X8            宽6像素，高8像素
 647            * 返 回 值：无
 648            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 649            */
 650          void OLED_ShowHexNum(int X, int Y, uint32_t Number, uint8_t Length, uint8_t FontSize)
 651          {
 652   1          uint8_t i, SingleNumber;
 653   1          for(i = 0; i < Length; i++) {       //遍历数字的每一位
 654   2              /*以十六进制提取数字的每一位*/
 655   2              SingleNumber = Number / OLED_Pow(16, Length - i - 1) % 16;
 656   2      
 657   2              if(SingleNumber < 10) {         //单个数字小于10
 658   3                  /*调用OLED_ShowChar函数，显示此数字*/
 659   3                  /*+ '0' 可将数字转换为字符格式*/
 660   3                  OLED_ShowChar(X + i * FontSize, Y, SingleNumber + '0', FontSize);
 661   3              } else {                                                //单个数字大于10
 662   3                  /*调用OLED_ShowChar函数，显示此数字*/
 663   3                  /*+ 'A' 可将数字转换为从A开始的十六进制字符*/
 664   3                  OLED_ShowChar(X + i * FontSize, Y, SingleNumber - 10 + 'A', FontSize);
 665   3              }
 666   2          }
 667   1      }
 668          
 669          /**
 670            * 函    数：OLED显示二进制数字（二进制，正整数）
 671            * 参    数：X 指定数字左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 12  

 672            * 参    数：Y 指定数字左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 673            * 参    数：Number 指定要显示的数字，范围：0x00000000~0xFFFFFFFF
 674            * 参    数：Length 指定数字的长度，范围：0~16
 675            * 参    数：FontSize 指定字体大小
 676            *           范围：OLED_8X16                宽8像素，高16像素
 677            *                 OLED_6X8            宽6像素，高8像素
 678            * 返 回 值：无
 679            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 680            */
 681          void OLED_ShowBinNum(int X, int Y, uint32_t Number, uint8_t Length, uint8_t FontSize)
 682          {
 683   1          uint8_t i;
 684   1          for(i = 0; i < Length; i++) {       //遍历数字的每一位
 685   2              /*调用OLED_ShowChar函数，依次显示每个数字*/
 686   2              /*Number / OLED_Pow(2, Length - i - 1) % 2 可以二进制提取数字的每一位*/
 687   2              /*+ '0' 可将数字转换为字符格式*/
 688   2              OLED_ShowChar(X + i * FontSize, Y, Number / OLED_Pow(2, Length - i - 1) % 2 + '0', FontSize);
 689   2          }
 690   1      }
 691          
 692          /**
 693            * 函    数：OLED显示浮点数字（十进制，小数）
 694            * 参    数：X 指定数字左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 695            * 参    数：Y 指定数字左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 696            * 参    数：Number 指定要显示的数字，范围：-4294967295.0~4294967295.0
 697            * 参    数：IntLength 指定数字的整数位长度，范围：0~10
 698            * 参    数：FraLength 指定数字的小数位长度，范围：0~9，小数进行四舍五入显示
 699            * 参    数：FontSize 指定字体大小
 700            *           范围：OLED_8X16                宽8像素，高16像素
 701            *                 OLED_6X8            宽6像素，高8像素
 702            * 返 回 值：无
 703            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 704            */
 705          void OLED_ShowFloatNum(int X, int Y, double Number, uint8_t IntLength, uint8_t FraLength, uint8_t FontSize
             -)
 706          {
 707   1          uint32_t PowNum, IntNum, FraNum;
 708   1      
 709   1          if(Number >= 0) {                                   //数字大于等于0
 710   2              OLED_ShowChar(X, Y, '+', FontSize);     //显示+号
 711   2          } else {                                                            //数字小于0
 712   2              OLED_ShowChar(X, Y, '-', FontSize);     //显示-号
 713   2              Number = -Number;                                       //Number取负
 714   2          }
 715   1      
 716   1          /*提取整数部分和小数部分*/
 717   1          IntNum = Number;                                            //直接赋值给整型变量，提取整数
 718   1          Number -= IntNum;                                           //将Number的整数减掉，防止之后将小数乘到整数时因数过大
             -成错误
 719   1          PowNum = OLED_Pow(10, FraLength);           //根据指定小数的位数，确定乘数
 720   1          FraNum = (unsigned long)(Number * PowNum + 0.5);            //将小数乘到整数，同时四舍五入，避
             -显示误差
 721   1          IntNum += FraNum / PowNum;                          //若四舍五入造成了进位，则需要再加给整数
 722   1      
 723   1          /*显示整数部分*/
 724   1          OLED_ShowNum(X + FontSize, Y, IntNum, IntLength, FontSize);
 725   1      
 726   1          /*显示小数点*/
 727   1          OLED_ShowChar(X + (IntLength + 1) * FontSize, Y, '.', FontSize);
 728   1      
 729   1          /*显示小数部分*/
 730   1          OLED_ShowNum(X + (IntLength + 2) * FontSize, Y, FraNum, FraLength, FontSize);
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 13  

 731   1      }
 732          
 733          /**
 734            * 函    数：OLED显示汉字串
 735            * 参    数：X 指定汉字串左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 736            * 参    数：Y 指定汉字串左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 737            * 参    数：Chinese 指定要显示的汉字串，范围：必须全部为汉字或者全角字符，
             -不要加入任何半角字符
 738            *           显示的汉字需要在OLED_Data.c里的OLED_CF16x16数组定义
 739            *           未找到指定汉字时，会显示默认图形（一个方框，内部一个问号）
 740            * 返 回 值：无
 741            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 742            */
 743          void OLED_ShowChinese(int X, int Y, char* Chinese)
 744          {
 745   1          uint8_t pChinese = 0;
 746   1          uint8_t pIndex;
 747   1          uint8_t i;
 748   1          char SingleChinese[OLED_CHN_CHAR_WIDTH + 1] = {0};
 749   1      
 750   1          for(i = 0; Chinese[i] != '\0'; i ++) {      //遍历汉字串
 751   2              SingleChinese[pChinese] = Chinese[i];   //提取汉字串数据到单个汉字数组
 752   2              pChinese ++;                                                    //计次自增
 753   2      
 754   2              /*当提取次数到达OLED_CHN_CHAR_WIDTH时，即代表提取到了一个完整的汉字*/
 755   2              if(pChinese >= OLED_CHN_CHAR_WIDTH) {
 756   3                  pChinese = 0;               //计次归零
 757   3      
 758   3                  /*遍历整个汉字字模库，寻找匹配的汉字*/
 759   3                  /*如果找到最后一个汉字（定义为空字符串），则表示汉字未在字模库
             -义，停止寻找*/
 760   3                  for(pIndex = 0; strcmp(OLED_CF16x16[pIndex].Index, "") != 0; pIndex ++) {
 761   4                      /*找到匹配的汉字*/
 762   4                      if(strcmp(OLED_CF16x16[pIndex].Index, SingleChinese) == 0) {
 763   5                          break;              //跳出循环，此时pIndex的值为指定汉字的索引
 764   5                      }
 765   4                  }
 766   3      
 767   3                  /*将汉字字模库OLED_CF16x16的指定数据以16*16的图像格式显示*/
 768   3                  OLED_ShowImage(X + ((i + 1) / OLED_CHN_CHAR_WIDTH - 1) * 16, Y, 16, 16, OLED_CF16x16[pIndex].D
             -ata);
 769   3              }
 770   2          }
 771   1      }
 772          
 773          /**
 774            * 函    数：OLED显示图像
 775            * 参    数：X 指定图像左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
 776            * 参    数：Y 指定图像左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
 777            * 参    数：Width 指定图像的宽度，范围：0~128
 778            * 参    数：Height 指定图像的高度，范围：0~64
 779            * 参    数：Image 指定要显示的图像
 780            * 返 回 值：无
 781            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 782            */
 783          void OLED_ShowImage(int X, int Y, uint8_t Width, uint8_t Height, const uint8_t* Image)
 784          {
 785   1          uint8_t i = 0, j = 0;
 786   1          int Page, Shift;
 787   1      
 788   1          /*将图像所在区域清空*/
 789   1          OLED_ClearArea(X, Y, Width, Height);
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 14  

 790   1      
 791   1          /*遍历指定图像涉及的相关页*/
 792   1          /*(Height - 1) / 8 + 1的目的是Height / 8并向上取整*/
 793   1          for(j = 0; j < (Height - 1) / 8 + 1; j ++) {
 794   2              /*遍历指定图像涉及的相关列*/
 795   2              for(i = 0; i < Width; i ++) {
 796   3                  if(X + i >= 0 && X + i <= 127) {    //超出屏幕的内容不显示
 797   4                      /*负数坐标在计算页地址和移位时需要加一个偏移*/
 798   4                      Page = Y / 8;
 799   4                      Shift = Y % 8;
 800   4                      if(Y < 0) {
 801   5                          Page -= 1;
 802   5                          Shift += 8;
 803   5                      }
 804   4      
 805   4                      if(Page + j >= 0 && Page + j <= 7) {    //超出屏幕的内容不显示
 806   5                          /*显示图像在当前页的内容*/
 807   5                          OLED_DisplayBuf[Page + j][X + i] |= Image[j * Width + i] << (Shift);
 808   5                      }
 809   4      
 810   4                      if(Page + j + 1 >= 0 && Page + j + 1 <= 7) {    //超出屏幕的内容不显示
 811   5                          /*显示图像在下一页的内容*/
 812   5                          OLED_DisplayBuf[Page + j + 1][X + i] |= Image[j * Width + i] >> (8 - Shift);
 813   5                      }
 814   4                  }
 815   3              }
 816   2          }
 817   1      }
 818          
 819          /**
 820            * 函    数：OLED使用printf函数打印格式化字符串
 821            * 参    数：X 指定格式化字符串左上角的横坐标，范围：-32768~32767，屏幕区域：
             -0~127
 822            * 参    数：Y 指定格式化字符串左上角的纵坐标，范围：-32768~32767，屏幕区域：
             -0~63
 823            * 参    数：FontSize 指定字体大小
 824            *           范围：OLED_8X16                宽8像素，高16像素
 825            *                 OLED_6X8            宽6像素，高8像素
 826            * 参    数：format 指定要显示的格式化字符串，范围：ASCII码可见字符组成的字
             -串
 827            * 参    数：... 格式化字符串参数列表
 828            * 返 回 值：无
 829            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 830            */
 831          /*
 832          void OLED_Printf(int X, int Y, uint8_t FontSize, char *format, ...)
 833          {
 834                  char String[256];                                               //定义字符数组
 835                  va_list arg;                                                    //定义可变参数列表数据类型的变量arg
 836                  va_start(arg, format);                                  //从format开始，接收参数列表到arg变量
 837                  vsprintf(String, format, arg);                  //使用vsprintf打印格式化字符串和参数列表到字符数组
             -
 838                  va_end(arg);                                                    //结束变量arg
 839                  OLED_ShowString(X, Y, String, FontSize);//OLED显示字符数组（字符串）
 840          
 841          }
 842          */
 843          
 844          /**
 845            * 函    数：OLED在指定位置画一个点
 846            * 参    数：X 指定点的横坐标，范围：-32768~32767，屏幕区域：0~127
 847            * 参    数：Y 指定点的纵坐标，范围：-32768~32767，屏幕区域：0~63
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 15  

 848            * 返 回 值：无
 849            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 850            */
 851          void OLED_DrawPoint(int X, int Y)
 852          {
 853   1          if(X >= 0 && X <= 127 && Y >= 0 && Y <= 63) {       //超出屏幕的内容不显示
 854   2              /*将显存数组指定位置的一个Bit数据置1*/
 855   2              OLED_DisplayBuf[Y / 8][X] |= 0x01 << (Y % 8);
 856   2          }
 857   1      }
 858          
 859          /**
 860            * 函    数：OLED获取指定位置点的值
 861            * 参    数：X 指定点的横坐标，范围：-32768~32767，屏幕区域：0~127
 862            * 参    数：Y 指定点的纵坐标，范围：-32768~32767，屏幕区域：0~63
 863            * 返 回 值：指定位置点是否处于点亮状态，1：点亮，0：熄灭
 864            */
 865          uint8_t OLED_GetPoint(int X, int Y)
 866          {
 867   1          if(X >= 0 && X <= 127 && Y >= 0 && Y <= 63) {       //超出屏幕的内容不读取
 868   2              /*判断指定位置的数据*/
 869   2              if(OLED_DisplayBuf[Y / 8][X] & 0x01 << (Y % 8)) {
 870   3                  return 1;   //为1，返回1
 871   3              }
 872   2          }
 873   1      
 874   1          return 0;           //否则，返回0
 875   1      }
 876          
 877          /**
 878            * 函    数：OLED画线
 879            * 参    数：X0 指定一个端点的横坐标，范围：-32768~32767，屏幕区域：0~127
 880            * 参    数：Y0 指定一个端点的纵坐标，范围：-32768~32767，屏幕区域：0~63
 881            * 参    数：X1 指定另一个端点的横坐标，范围：-32768~32767，屏幕区域：0~127
 882            * 参    数：Y1 指定另一个端点的纵坐标，范围：-32768~32767，屏幕区域：0~63
 883            * 返 回 值：无
 884            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
 885            */
 886          void OLED_DrawLine(int X0, int Y0, int X1, int Y1)
 887          {
 888   1          int x, y, dx, dy, d, incrE, incrNE, temp;
 889   1          int x0 = X0, y0 = Y0, x1 = X1, y1 = Y1;
 890   1          uint8_t yflag = 0, xyflag = 0;
 891   1      
 892   1          if(y0 == y1) {      //横线单独处理
 893   2              /*0号点X坐标大于1号点X坐标，则交换两点X坐标*/
 894   2              if(x0 > x1) {
 895   3                  temp = x0;
 896   3                  x0 = x1;
 897   3                  x1 = temp;
 898   3              }
 899   2      
 900   2              /*遍历X坐标*/
 901   2              for(x = x0; x <= x1; x ++) {
 902   3                  OLED_DrawPoint(x, y0);      //依次画点
 903   3              }
 904   2          } else if(x0 == x1) {       //竖线单独处理
 905   2              /*0号点Y坐标大于1号点Y坐标，则交换两点Y坐标*/
 906   2              if(y0 > y1) {
 907   3                  temp = y0;
 908   3                  y0 = y1;
 909   3                  y1 = temp;
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 16  

 910   3              }
 911   2      
 912   2              /*遍历Y坐标*/
 913   2              for(y = y0; y <= y1; y ++) {
 914   3                  OLED_DrawPoint(x0, y);      //依次画点
 915   3              }
 916   2          } else {                    //斜线
 917   2              /*使用Bresenham算法画直线，可以避免耗时的浮点运算，效率更高*/
 918   2              /*参考文档：https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf*/
 919   2              /*参考教程：https://www.bilibili.com/video/BV1364y1d7Lo*/
 920   2      
 921   2              if(x0 > x1) {   //0号点X坐标大于1号点X坐标
 922   3                  /*交换两点坐标*/
 923   3                  /*交换后不影响画线，但是画线方向由第一、二、三、四象限变为第一
             -四象限*/
 924   3                  temp = x0;
 925   3                  x0 = x1;
 926   3                  x1 = temp;
 927   3                  temp = y0;
 928   3                  y0 = y1;
 929   3                  y1 = temp;
 930   3              }
 931   2      
 932   2              if(y0 > y1) {   //0号点Y坐标大于1号点Y坐标
 933   3                  /*将Y坐标取负*/
 934   3                  /*取负后影响画线，但是画线方向由第一、四象限变为第一象限*/
 935   3                  y0 = -y0;
 936   3                  y1 = -y1;
 937   3      
 938   3                  /*置标志位yflag，记住当前变换，在后续实际画线时，再将坐标换回来*/
 939   3                  yflag = 1;
 940   3              }
 941   2      
 942   2              if(y1 - y0 > x1 - x0) { //画线斜率大于1
 943   3                  /*将X坐标与Y坐标互换*/
 944   3                  /*互换后影响画线，但是画线方向由第一象限0~90度范围变为第一象限0~45
             -度范围*/
 945   3                  temp = x0;
 946   3                  x0 = y0;
 947   3                  y0 = temp;
 948   3                  temp = x1;
 949   3                  x1 = y1;
 950   3                  y1 = temp;
 951   3      
 952   3                  /*置标志位xyflag，记住当前变换，在后续实际画线时，再将坐标换回来*/
 953   3                  xyflag = 1;
 954   3              }
 955   2      
 956   2              /*以下为Bresenham算法画直线*/
 957   2              /*算法要求，画线方向必须为第一象限0~45度范围*/
 958   2              dx = x1 - x0;
 959   2              dy = y1 - y0;
 960   2              incrE = 2 * dy;
 961   2              incrNE = 2 * (dy - dx);
 962   2              d = 2 * dy - dx;
 963   2              x = x0;
 964   2              y = y0;
 965   2      
 966   2              /*画起始点，同时判断标志位，将坐标换回来*/
 967   2              if(yflag && xyflag) {
 968   3                  OLED_DrawPoint(y, -x);
 969   3              } else if(yflag)                {
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 17  

 970   3                  OLED_DrawPoint(x, -y);
 971   3              } else if(xyflag)       {
 972   3                  OLED_DrawPoint(y, x);
 973   3              } else                          {
 974   3                  OLED_DrawPoint(x, y);
 975   3              }
 976   2      
 977   2              while(x < x1) { //遍历X轴的每个点
 978   3                  x ++;
 979   3                  if(d < 0) { //下一个点在当前点东方
 980   4                      d += incrE;
 981   4                  } else {            //下一个点在当前点东北方
 982   4                      y ++;
 983   4                      d += incrNE;
 984   4                  }
 985   3      
 986   3                  /*画每一个点，同时判断标志位，将坐标换回来*/
 987   3                  if(yflag && xyflag) {
 988   4                      OLED_DrawPoint(y, -x);
 989   4                  } else if(yflag)            {
 990   4                      OLED_DrawPoint(x, -y);
 991   4                  } else if(xyflag)   {
 992   4                      OLED_DrawPoint(y, x);
 993   4                  } else                              {
 994   4                      OLED_DrawPoint(x, y);
 995   4                  }
 996   3              }
 997   2          }
 998   1      }
 999          
1000          /**
1001            * 函    数：OLED矩形
1002            * 参    数：X 指定矩形左上角的横坐标，范围：-32768~32767，屏幕区域：0~127
1003            * 参    数：Y 指定矩形左上角的纵坐标，范围：-32768~32767，屏幕区域：0~63
1004            * 参    数：Width 指定矩形的宽度，范围：0~128
1005            * 参    数：Height 指定矩形的高度，范围：0~64
1006            * 参    数：IsFilled 指定矩形是否填充
1007            *           范围：OLED_UNFILLED            不填充
1008            *                 OLED_FILLED                 填充
1009            * 返 回 值：无
1010            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
1011            */
1012          void OLED_DrawRectangle(int X, int Y, uint8_t Width, uint8_t Height, uint8_t IsFilled)
1013          {
1014   1          int i, j;
1015   1          if(!IsFilled) {     //指定矩形不填充
1016   2              /*遍历上下X坐标，画矩形上下两条线*/
1017   2              for(i = X; i < X + Width; i ++) {
1018   3                  OLED_DrawPoint(i, Y);
1019   3                  OLED_DrawPoint(i, Y + Height - 1);
1020   3              }
1021   2              /*遍历左右Y坐标，画矩形左右两条线*/
1022   2              for(i = Y; i < Y + Height; i ++) {
1023   3                  OLED_DrawPoint(X, i);
1024   3                  OLED_DrawPoint(X + Width - 1, i);
1025   3              }
1026   2          } else {                    //指定矩形填充
1027   2              /*遍历X坐标*/
1028   2              for(i = X; i < X + Width; i ++) {
1029   3                  /*遍历Y坐标*/
1030   3                  for(j = Y; j < Y + Height; j ++) {
1031   4                      /*在指定区域画点，填充满矩形*/
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 18  

1032   4                      OLED_DrawPoint(i, j);
1033   4                  }
1034   3              }
1035   2          }
1036   1      }
1037          
1038          /**
1039            * 函    数：OLED三角形
1040            * 参    数：X0 指定第一个端点的横坐标，范围：-32768~32767，屏幕区域：0~127
1041            * 参    数：Y0 指定第一个端点的纵坐标，范围：-32768~32767，屏幕区域：0~63
1042            * 参    数：X1 指定第二个端点的横坐标，范围：-32768~32767，屏幕区域：0~127
1043            * 参    数：Y1 指定第二个端点的纵坐标，范围：-32768~32767，屏幕区域：0~63
1044            * 参    数：X2 指定第三个端点的横坐标，范围：-32768~32767，屏幕区域：0~127
1045            * 参    数：Y2 指定第三个端点的纵坐标，范围：-32768~32767，屏幕区域：0~63
1046            * 参    数：IsFilled 指定三角形是否填充
1047            *           范围：OLED_UNFILLED            不填充
1048            *                 OLED_FILLED                 填充
1049            * 返 回 值：无
1050            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
1051            */
1052          void OLED_DrawTriangle(int X0, int Y0, int X1, int Y1, int X2, int Y2, uint8_t IsFilled)
1053          {
1054   1          int minx = X0, miny = Y0, maxx = X0, maxy = Y0;
1055   1          int i, j;
1056   1          // int vx[3] = {X0, X1, X2};
1057   1          // int vy[3] = {Y0, Y1, Y2};
1058   1          int vx[3], vy[3];
1059   1          vx[0] = X0;
1060   1          vx[1] = X1;
1061   1          vx[2] = X2;
1062   1          vy[0] = Y0;
1063   1          vy[1] = Y1;
1064   1          vy[2] = Y2;
1065   1          if(!IsFilled) {             //指定三角形不填充
1066   2              /*调用画线函数，将三个点用直线连接*/
1067   2              OLED_DrawLine(X0, Y0, X1, Y1);
1068   2              OLED_DrawLine(X0, Y0, X2, Y2);
1069   2              OLED_DrawLine(X1, Y1, X2, Y2);
1070   2          } else {                            //指定三角形填充
1071   2              /*找到三个点最小的X、Y坐标*/
1072   2              if(X1 < minx) {
1073   3                  minx = X1;
1074   3              }
1075   2              if(X2 < minx) {
1076   3                  minx = X2;
1077   3              }
1078   2              if(Y1 < miny) {
1079   3                  miny = Y1;
1080   3              }
1081   2              if(Y2 < miny) {
1082   3                  miny = Y2;
1083   3              }
1084   2      
1085   2              /*找到三个点最大的X、Y坐标*/
1086   2              if(X1 > maxx) {
1087   3                  maxx = X1;
1088   3              }
1089   2              if(X2 > maxx) {
1090   3                  maxx = X2;
1091   3              }
1092   2              if(Y1 > maxy) {
1093   3                  maxy = Y1;
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 19  

1094   3              }
1095   2              if(Y2 > maxy) {
1096   3                  maxy = Y2;
1097   3              }
1098   2      
1099   2              /*最小最大坐标之间的矩形为可能需要填充的区域*/
1100   2              /*遍历此区域中所有的点*/
1101   2              /*遍历X坐标*/
1102   2              for(i = minx; i <= maxx; i ++) {
1103   3                  /*遍历Y坐标*/
1104   3                  for(j = miny; j <= maxy; j ++) {
1105   4                      /*调用OLED_pnpoly，判断指定点是否在指定三角形之中*/
1106   4                      /*如果在，则画点，如果不在，则不做处理*/
1107   4                      if(OLED_pnpoly(3, vx, vy, i, j)) {
1108   5                          OLED_DrawPoint(i, j);
1109   5                      }
1110   4                  }
1111   3              }
1112   2          }
1113   1      }
1114          
1115          /**
1116            * 函    数：OLED画圆
1117            * 参    数：X 指定圆的圆心横坐标，范围：-32768~32767，屏幕区域：0~127
1118            * 参    数：Y 指定圆的圆心纵坐标，范围：-32768~32767，屏幕区域：0~63
1119            * 参    数：Radius 指定圆的半径，范围：0~255
1120            * 参    数：IsFilled 指定圆是否填充
1121            *           范围：OLED_UNFILLED            不填充
1122            *                 OLED_FILLED                 填充
1123            * 返 回 值：无
1124            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
1125            */
1126          void OLED_DrawCircle(int X, int Y, uint8_t Radius, uint8_t IsFilled)
1127          {
1128   1          int x, y, d, j;
1129   1      
1130   1          /*使用Bresenham算法画圆，可以避免耗时的浮点运算，效率更高*/
1131   1          /*参考文档：https://www.cs.montana.edu/courses/spring2009/425/dslectures/Bresenham.pdf*/
1132   1          /*参考教程：https://www.bilibili.com/video/BV1VM4y1u7wJ*/
1133   1      
1134   1          d = 1 - Radius;
1135   1          x = 0;
1136   1          y = Radius;
1137   1      
1138   1          /*画每个八分之一圆弧的起始点*/
1139   1          OLED_DrawPoint(X + x, Y + y);
1140   1          OLED_DrawPoint(X - x, Y - y);
1141   1          OLED_DrawPoint(X + y, Y + x);
1142   1          OLED_DrawPoint(X - y, Y - x);
1143   1      
1144   1          if(IsFilled) {      //指定圆填充
1145   2              /*遍历起始点Y坐标*/
1146   2              for(j = -y; j < y; j ++) {
1147   3                  /*在指定区域画点，填充部分圆*/
1148   3                  OLED_DrawPoint(X, Y + j);
1149   3              }
1150   2          }
1151   1      
1152   1          while(x < y) {      //遍历X轴的每个点
1153   2              x ++;
1154   2              if(d < 0) {     //下一个点在当前点东方
1155   3                  d += 2 * x + 1;
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 20  

1156   3              } else {                //下一个点在当前点东南方
1157   3                  y --;
1158   3                  d += 2 * (x - y) + 1;
1159   3              }
1160   2      
1161   2              /*画每个八分之一圆弧的点*/
1162   2              OLED_DrawPoint(X + x, Y + y);
1163   2              OLED_DrawPoint(X + y, Y + x);
1164   2              OLED_DrawPoint(X - x, Y - y);
1165   2              OLED_DrawPoint(X - y, Y - x);
1166   2              OLED_DrawPoint(X + x, Y - y);
1167   2              OLED_DrawPoint(X + y, Y - x);
1168   2              OLED_DrawPoint(X - x, Y + y);
1169   2              OLED_DrawPoint(X - y, Y + x);
1170   2      
1171   2              if(IsFilled) {  //指定圆填充
1172   3                  /*遍历中间部分*/
1173   3                  for(j = -y; j < y; j ++) {
1174   4                      /*在指定区域画点，填充部分圆*/
1175   4                      OLED_DrawPoint(X + x, Y + j);
1176   4                      OLED_DrawPoint(X - x, Y + j);
1177   4                  }
1178   3      
1179   3                  /*遍历两侧部分*/
1180   3                  for(j = -x; j < x; j ++) {
1181   4                      /*在指定区域画点，填充部分圆*/
1182   4                      OLED_DrawPoint(X - y, Y + j);
1183   4                      OLED_DrawPoint(X + y, Y + j);
1184   4                  }
1185   3              }
1186   2          }
1187   1      }
1188          
1189          /**
1190            * 函    数：OLED画椭圆
1191            * 参    数：X 指定椭圆的圆心横坐标，范围：-32768~32767，屏幕区域：0~127
1192            * 参    数：Y 指定椭圆的圆心纵坐标，范围：-32768~32767，屏幕区域：0~63
1193            * 参    数：A 指定椭圆的横向半轴长度，范围：0~255
1194            * 参    数：B 指定椭圆的纵向半轴长度，范围：0~255
1195            * 参    数：IsFilled 指定椭圆是否填充
1196            *           范围：OLED_UNFILLED            不填充
1197            *                 OLED_FILLED                 填充
1198            * 返 回 值：无
1199            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
1200            */
1201          void OLED_DrawEllipse(int X, int Y, uint8_t A, uint8_t B, uint8_t IsFilled)
1202          {
1203   1          int x, y, j;
1204   1          int a = A, b = B;
1205   1          float d1, d2;
1206   1      
1207   1          /*使用Bresenham算法画椭圆，可以避免部分耗时的浮点运算，效率更高*/
1208   1          /*参考链接：https://blog.csdn.net/myf_666/article/details/128167392*/
1209   1      
1210   1          x = 0;
1211   1          y = b;
1212   1          d1 = b * b + a * a * (-b + 0.5);
1213   1      
1214   1          if(IsFilled) {      //指定椭圆填充
1215   2              /*遍历起始点Y坐标*/
1216   2              for(j = -y; j < y; j ++) {
1217   3                  /*在指定区域画点，填充部分椭圆*/
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 21  

1218   3                  OLED_DrawPoint(X, Y + j);
1219   3                  OLED_DrawPoint(X, Y + j);
1220   3              }
1221   2          }
1222   1      
1223   1          /*画椭圆弧的起始点*/
1224   1          OLED_DrawPoint(X + x, Y + y);
1225   1          OLED_DrawPoint(X - x, Y - y);
1226   1          OLED_DrawPoint(X - x, Y + y);
1227   1          OLED_DrawPoint(X + x, Y - y);
1228   1      
1229   1          /*画椭圆中间部分*/
1230   1          while(b * b * (x + 1) < a * a * (y - 0.5)) {
1231   2              if(d1 <= 0) {   //下一个点在当前点东方
1232   3                  d1 += b * b * (2 * x + 3);
1233   3              } else {                        //下一个点在当前点东南方
1234   3                  d1 += b * b * (2 * x + 3) + a * a * (-2 * y + 2);
1235   3                  y --;
1236   3              }
1237   2              x ++;
1238   2      
1239   2              if(IsFilled) {  //指定椭圆填充
1240   3                  /*遍历中间部分*/
1241   3                  for(j = -y; j < y; j ++) {
1242   4                      /*在指定区域画点，填充部分椭圆*/
1243   4                      OLED_DrawPoint(X + x, Y + j);
1244   4                      OLED_DrawPoint(X - x, Y + j);
1245   4                  }
1246   3              }
1247   2      
1248   2              /*画椭圆中间部分圆弧*/
1249   2              OLED_DrawPoint(X + x, Y + y);
1250   2              OLED_DrawPoint(X - x, Y - y);
1251   2              OLED_DrawPoint(X - x, Y + y);
1252   2              OLED_DrawPoint(X + x, Y - y);
1253   2          }
1254   1      
1255   1          /*画椭圆两侧部分*/
1256   1          d2 = b * b * (x + 0.5) * (x + 0.5) + a * a * (y - 1) * (y - 1) - a * a * b * b;
1257   1      
1258   1          while(y > 0) {
1259   2              if(d2 <= 0) {   //下一个点在当前点东方
1260   3                  d2 += b * b * (2 * x + 2) + a * a * (-2 * y + 3);
1261   3                  x ++;
1262   3      
1263   3              } else {                        //下一个点在当前点东南方
1264   3                  d2 += a * a * (-2 * y + 3);
1265   3              }
1266   2              y --;
1267   2      
1268   2              if(IsFilled) {  //指定椭圆填充
1269   3                  /*遍历两侧部分*/
1270   3                  for(j = -y; j < y; j ++) {
1271   4                      /*在指定区域画点，填充部分椭圆*/
1272   4                      OLED_DrawPoint(X + x, Y + j);
1273   4                      OLED_DrawPoint(X - x, Y + j);
1274   4                  }
1275   3              }
1276   2      
1277   2              /*画椭圆两侧部分圆弧*/
1278   2              OLED_DrawPoint(X + x, Y + y);
1279   2              OLED_DrawPoint(X - x, Y - y);
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 22  

1280   2              OLED_DrawPoint(X - x, Y + y);
1281   2              OLED_DrawPoint(X + x, Y - y);
1282   2          }
1283   1      }
1284          
1285          /**
1286            * 函    数：OLED画圆弧
1287            * 参    数：X 指定圆弧的圆心横坐标，范围：-32768~32767，屏幕区域：0~127
1288            * 参    数：Y 指定圆弧的圆心纵坐标，范围：-32768~32767，屏幕区域：0~63
1289            * 参    数：Radius 指定圆弧的半径，范围：0~255
1290            * 参    数：StartAngle 指定圆弧的起始角度，范围：-180~180
1291            *           水平向右为0度，水平向左为180度或-180度，下方为正数，上方为负数，
             -顺时针旋转
1292            * 参    数：EndAngle 指定圆弧的终止角度，范围：-180~180
1293            *           水平向右为0度，水平向左为180度或-180度，下方为正数，上方为负数，
             -顺时针旋转
1294            * 参    数：IsFilled 指定圆弧是否填充，填充后为扇形
1295            *           范围：OLED_UNFILLED            不填充
1296            *                 OLED_FILLED                 填充
1297            * 返 回 值：无
1298            * 说    明：调用此函数后，要想真正地呈现在屏幕上，还需调用更新函数
1299            */
1300          void OLED_DrawArc(int X, int Y, uint8_t Radius, int StartAngle, int EndAngle, uint8_t IsFilled)
1301          {
1302   1          int x, y, d, j;
1303   1      
1304   1          /*此函数借用Bresenham算法画圆的方法*/
1305   1      
1306   1          d = 1 - Radius;
1307   1          x = 0;
1308   1          y = Radius;
1309   1      
1310   1          /*在画圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，则
             -做处理*/
1311   1          if(OLED_IsInAngle(x, y, StartAngle, EndAngle))      {
1312   2              OLED_DrawPoint(X + x, Y + y);
1313   2          }
1314   1          if(OLED_IsInAngle(-x, -y, StartAngle, EndAngle)) {
1315   2              OLED_DrawPoint(X - x, Y - y);
1316   2          }
1317   1          if(OLED_IsInAngle(y, x, StartAngle, EndAngle)) {
1318   2              OLED_DrawPoint(X + y, Y + x);
1319   2          }
1320   1          if(OLED_IsInAngle(-y, -x, StartAngle, EndAngle)) {
1321   2              OLED_DrawPoint(X - y, Y - x);
1322   2          }
1323   1      
1324   1          if(IsFilled) {      //指定圆弧填充
1325   2              /*遍历起始点Y坐标*/
1326   2              for(j = -y; j < y; j ++) {
1327   3                  /*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点，
             -在，则不做处理*/
1328   3                  if(OLED_IsInAngle(0, j, StartAngle, EndAngle)) {
1329   4                      OLED_DrawPoint(X, Y + j);
1330   4                  }
1331   3              }
1332   2          }
1333   1      
1334   1          while(x < y) {      //遍历X轴的每个点
1335   2              x ++;
1336   2              if(d < 0) {     //下一个点在当前点东方
1337   3                  d += 2 * x + 1;
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 23  

1338   3              } else {                //下一个点在当前点东南方
1339   3                  y --;
1340   3                  d += 2 * (x - y) + 1;
1341   3              }
1342   2      
1343   2              /*在画圆的每个点时，判断指定点是否在指定角度内，在，则画点，不在，
             -则不做处理*/
1344   2              if(OLED_IsInAngle(x, y, StartAngle, EndAngle)) {
1345   3                  OLED_DrawPoint(X + x, Y + y);
1346   3              }
1347   2              if(OLED_IsInAngle(y, x, StartAngle, EndAngle)) {
1348   3                  OLED_DrawPoint(X + y, Y + x);
1349   3              }
1350   2              if(OLED_IsInAngle(-x, -y, StartAngle, EndAngle)) {
1351   3                  OLED_DrawPoint(X - x, Y - y);
1352   3              }
1353   2              if(OLED_IsInAngle(-y, -x, StartAngle, EndAngle)) {
1354   3                  OLED_DrawPoint(X - y, Y - x);
1355   3              }
1356   2              if(OLED_IsInAngle(x, -y, StartAngle, EndAngle)) {
1357   3                  OLED_DrawPoint(X + x, Y - y);
1358   3              }
1359   2              if(OLED_IsInAngle(y, -x, StartAngle, EndAngle)) {
1360   3                  OLED_DrawPoint(X + y, Y - x);
1361   3              }
1362   2              if(OLED_IsInAngle(-x, y, StartAngle, EndAngle)) {
1363   3                  OLED_DrawPoint(X - x, Y + y);
1364   3              }
1365   2              if(OLED_IsInAngle(-y, x, StartAngle, EndAngle)) {
1366   3                  OLED_DrawPoint(X - y, Y + x);
1367   3              }
1368   2      
1369   2              if(IsFilled) {  //指定圆弧填充
1370   3                  /*遍历中间部分*/
1371   3                  for(j = -y; j < y; j ++) {
1372   4                      /*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点
             -不在，则不做处理*/
1373   4                      if(OLED_IsInAngle(x, j, StartAngle, EndAngle)) {
1374   5                          OLED_DrawPoint(X + x, Y + j);
1375   5                      }
1376   4                      if(OLED_IsInAngle(-x, j, StartAngle, EndAngle)) {
1377   5                          OLED_DrawPoint(X - x, Y + j);
1378   5                      }
1379   4                  }
1380   3      
1381   3                  /*遍历两侧部分*/
1382   3                  for(j = -x; j < x; j ++) {
1383   4                      /*在填充圆的每个点时，判断指定点是否在指定角度内，在，则画点
             -不在，则不做处理*/
1384   4                      if(OLED_IsInAngle(-y, j, StartAngle, EndAngle)) {
1385   5                          OLED_DrawPoint(X - y, Y + j);
1386   5                      }
1387   4                      if(OLED_IsInAngle(y, j, StartAngle, EndAngle)) {
1388   5                          OLED_DrawPoint(X + y, Y + j);
1389   5                      }
1390   4                  }
1391   3              }
1392   2          }
1393   1      }
1394          
1395          
1396          /*********************功能函数*/
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 24  

1397          
1398          
1399          /**********小恐龙部分**********/
1400          
1401          void oled_set_pos(unsigned char x, unsigned char y) //设置光标位置
1402          {
1403   1          OLED_WriteCommand(0xb0 + y);
1404   1          OLED_WriteCommand(((x & 0xf0) >> 4) | 0x10);
1405   1          OLED_WriteCommand((x & 0x0f));
1406   1      }
1407          
1408          void delay_ms(unsigned int time) //@27MHz 毫秒延时
1409          {
1410   1          unsigned int y;
1411   1          for(y = 0; y < time; y++) {
1412   2              unsigned char i, j;
1413   2      
1414   2              i = 27;
1415   2              j = 64;
1416   2              do {
1417   3                  while(--j);
1418   3              } while(--i);
1419   2          }
1420   1      }
1421          
1422          void delay_us() //@27MHz 5微秒的延时
1423          {
1424   1      
1425   1          unsigned char i;
1426   1      
1427   1          _nop_();
1428   1          i = 31;
1429   1          while(--i);
1430   1      }
1431          
1432          
1433          void oled_drawbmp_block_clear(int bx, int by, int clear_size)
1434          {
1435   1          unsigned int i;
1436   1          oled_set_pos(bx, by);
1437   1          OLED_I2C_Start();
1438   1          OLED_I2C_SendByte(0x78);
1439   1          OLED_I2C_SendByte(0x40);
1440   1      
1441   1          for(i = 0; i < clear_size; i++) {
1442   2              if(bx + i > 128) break;
1443   2              OLED_I2C_SendByte(0x0);
1444   2          }
1445   1          OLED_I2C_Stop();
1446   1      }
1447          
1448          void OLED_DrawGround()
1449          {
1450   1          static unsigned int pos = 0;
1451   1          unsigned char speed = 5;
1452   1          unsigned int ground_length = sizeof(GROUND);
1453   1          unsigned char x;
1454   1      
1455   1          oled_set_pos(0, 7);
1456   1          OLED_I2C_Start();
1457   1          OLED_I2C_SendByte(0x78);
1458   1          OLED_I2C_SendByte(0x40);
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 25  

1459   1          for(x = 0; x < 128; x++) {
1460   2              OLED_I2C_SendByte(GROUND[(x + pos) % ground_length]);
1461   2          }
1462   1          OLED_I2C_Stop();
1463   1      
1464   1          pos = pos + speed;
1465   1          //if(pos>ground_length) pos=0;
1466   1      }
1467          
1468          
1469          // 绘制云朵
1470          void OLED_DrawCloud()
1471          {
1472   1          static int pos = 128;
1473   1          static char height = 0;
1474   1          char speed = 3;
1475   1          unsigned int i = 0;
1476   1          int x;
1477   1          int start_x = 0;
1478   1          int length = sizeof(CLOUD);
1479   1          unsigned char byte;
1480   1      
1481   1          //if (pos + length <= -speed) pos = 128;
1482   1      
1483   1          if(pos + length <= -speed) {
1484   2              pos = 128;
1485   2              height = rand() % 3;
1486   2          }
1487   1          if(pos < 0) {
1488   2              start_x = -pos;
1489   2              oled_set_pos(0, 1 + height);
1490   2          } else {
1491   2              oled_set_pos(pos, 1 + height);
1492   2          }
1493   1      
1494   1          OLED_I2C_Start();
1495   1          OLED_I2C_SendByte(0x78);
1496   1          OLED_I2C_SendByte(0x40);
1497   1          for(x = start_x; x < length + speed; x++) {
1498   2              if(pos + x > 127) break;
1499   2              if(x < length) byte = CLOUD[x];
1500   2              else byte = 0x0;
1501   2      
1502   2              OLED_I2C_SendByte(byte);
1503   2      
1504   2          }
1505   1          OLED_I2C_Stop();
1506   1      
1507   1          pos = pos - speed;
1508   1      }
1509          
1510          // 绘制小恐龙
1511          void OLED_DrawDino()
1512          {
1513   1          static unsigned char dino_dir = 0;
1514   1          unsigned int j = 0;
1515   1          unsigned char x, y;
1516   1          unsigned char byte;
1517   1      
1518   1          dino_dir++;
1519   1          dino_dir = dino_dir % 2;
1520   1          for(y = 0; y < 2; y++) {
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 26  

1521   2              oled_set_pos(16, 6 + y);
1522   2              OLED_I2C_Start();
1523   2              OLED_I2C_SendByte(0x78);
1524   2              OLED_I2C_SendByte(0x40);
1525   2              for(x = 0; x < 16; x++) {
1526   3                  j = y * 16 + x;
1527   3                  byte = DINO[dino_dir][j];
1528   3      
1529   3                  OLED_I2C_SendByte(byte);
1530   3              }
1531   2              OLED_I2C_Stop();
1532   2          }
1533   1      }
1534          
1535          // 绘制仙人掌障碍物
1536          void OLED_DrawCactus()
1537          {
1538   1          char speed = 5;
1539   1          static int pos = 128;
1540   1          int start_x = 0;
1541   1          int length = sizeof(CACTUS_2) / 2;
*** WARNING C198 IN LINE 1541 OF oled.c: sizeof returns zero
1542   1      
1543   1          unsigned int j = 0;
1544   1          unsigned char x, y;
1545   1          unsigned char byte;
1546   1      
1547   1          if(pos + length <= 0) {
1548   2              oled_drawbmp_block_clear(0, 6, speed);
1549   2              pos = 128;
1550   2          }
1551   1      
1552   1          for(y = 0; y < 2; y++) {
1553   2              if(pos < 0) {
1554   3                  start_x = -pos;
1555   3                  oled_set_pos(0, 6 + y);
1556   3              } else {
1557   3                  oled_set_pos(pos, 6 + y);
1558   3              }
1559   2      
1560   2              OLED_I2C_Start();
1561   2              OLED_I2C_SendByte(0x78);
1562   2              OLED_I2C_SendByte(0x40);
1563   2      
1564   2              for(x = start_x; x < length; x++) {
1565   3                  if(pos + x > 127) break;
1566   3                  j = y * length + x;
1567   3                  byte = CACTUS_2[j];
1568   3                  OLED_I2C_SendByte(byte);
1569   3              }
1570   2              OLED_I2C_Stop();
1571   2          }
1572   1          oled_drawbmp_block_clear(pos + length, 6, speed); // 清除残影
1573   1          pos = pos - speed;
1574   1      }
1575          
1576          
1577          // 绘制随机出现的仙人掌障碍物
1578          int OLED_DrawCactusRandom(unsigned char ver, unsigned char reset)
1579          {
1580   1          char speed = 5;
1581   1          static int pos = 128;
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 27  

1582   1          int start_x = 0;
1583   1          int length = 0;
1584   1      
1585   1          unsigned int i = 0, j = 0;
1586   1          unsigned char x, y;
1587   1          unsigned char byte;
1588   1          if(reset == 1) {
1589   2              pos = 128;
1590   2              oled_drawbmp_block_clear(0, 6, speed);
1591   2              return 128;
1592   2          }
1593   1          if(ver == 0) length = 8;  //sizeof(CACTUS_1) / 2;
1594   1          else if(ver == 1) length = 16;  //sizeof(CACTUS_2) / 2;
1595   1          else if(ver == 2 || ver == 3) length = 24;
1596   1      
1597   1          for(y = 0; y < 2; y++) {
1598   2              if(pos < 0) {
1599   3                  start_x = -pos;
1600   3                  oled_set_pos(0, 6 + y);
1601   3              } else {
1602   3                  oled_set_pos(pos, 6 + y);
1603   3              }
1604   2      
1605   2              OLED_I2C_Start();
1606   2              OLED_I2C_SendByte(0x78);
1607   2              OLED_I2C_SendByte(0x40);
1608   2      
1609   2              for(x = start_x; x < length; x++) {
1610   3                  if(pos + x > 127) break;
1611   3      
1612   3                  j = y * length + x;
1613   3                  if(ver == 0) byte = CACTUS_1[j];
1614   3                  else if(ver == 1) byte = CACTUS_2[j];
1615   3                  else if(ver == 2) byte = CACTUS_3[j];
1616   3                  else byte = CACTUS_4[j];
1617   3      
1618   3                  OLED_I2C_SendByte(byte);
1619   3              }
1620   2              OLED_I2C_Stop();
1621   2          }
1622   1      
1623   1          oled_drawbmp_block_clear(pos + length, 6, speed);
1624   1      
1625   1          pos = pos - speed;
1626   1          return pos + speed;
1627   1      }
1628          
1629          
1630          
1631          
1632          // 绘制跳跃小恐龙
1633          int OLED_DrawDinoJump(char reset)
1634          {
1635   1          char speed_arr[] = {1, 1, 3, 3, 4, 4, 5, 6, 7};
1636   1          static char speed_idx = sizeof(speed_arr) -1;
1637   1          static int height = 0;
1638   1          static char dir = 0;
1639   1          //char speed = 4;
1640   1      
1641   1          unsigned int j = 0;
1642   1          unsigned char x, y;
1643   1          char offset = 0;
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 28  

1644   1          unsigned char byte;
1645   1          if(reset == 1) {
1646   2              height = 0;
1647   2              dir = 0;
1648   2              speed_idx = sizeof(speed_arr) -1;
1649   2              return 0;
1650   2          }
1651   1          if(dir == 0) {
1652   2              height += speed_arr[speed_idx];
1653   2              speed_idx --;
1654   2              if(speed_idx < 0) speed_idx = 0;
1655   2          }
1656   1          if(dir == 1) {
1657   2              height -= speed_arr[speed_idx];
1658   2              speed_idx ++;
1659   2              if(speed_idx > sizeof(speed_arr) -1) speed_idx = sizeof(speed_arr) -1;
1660   2          }
1661   1          if(height >= 31) {
1662   2              dir = 1;
1663   2              height = 31;
1664   2          }
1665   1          if(height <= 0) {
1666   2              dir = 0;
1667   2              height = 0;
1668   2          }
1669   1          if(height <= 7) offset = 0;
1670   1          else if(height <= 15) offset = 1;
1671   1          else if(height <= 23) offset = 2;
1672   1          else if(height <= 31) offset = 3;
1673   1          else offset = 4;
1674   1      
1675   1          for(y = 0; y < 3; y++) { // 4
1676   2              oled_set_pos(16, 5 - offset + y);
1677   2      
1678   2              OLED_I2C_Start();
1679   2              OLED_I2C_SendByte(0x78);
1680   2              OLED_I2C_SendByte(0x40);
1681   2              for(x = 0; x < 16; x++) { // 32
1682   3                  j = y * 16 + x; // 32
1683   3                  byte = DINO_JUMP[height % 8][j];
1684   3      
1685   3                  OLED_I2C_SendByte(byte);
1686   3              }
1687   2              OLED_I2C_Stop();
1688   2          }
1689   1          if(dir == 0) oled_drawbmp_block_clear(16, 8 - offset, 16);
1690   1          if(dir == 1) oled_drawbmp_block_clear(16, 4 - offset, 16);
1691   1          return height;
1692   1      }
1693          
1694          // 绘制重启
1695          void OLED_DrawRestart()
1696          {
1697   1          unsigned int j = 0; 
1698   1          unsigned char x, y;
1699   1          unsigned char byte;
1700   1          for(y = 2; y < 5; y++) {
1701   2              oled_set_pos(52, y);
1702   2              OLED_I2C_Start();
1703   2              OLED_I2C_SendByte(0x78);
1704   2              OLED_I2C_SendByte(0x40);
1705   2              for(x = 0; x < 24; x++) {
C51 COMPILER V9.60.7.0   OLED                                                              12/06/2024 10:38:26 PAGE 29  

1706   3                  byte = RESTART[j++];
1707   3                  OLED_I2C_SendByte(byte);
1708   3              }
1709   2              OLED_I2C_Stop();
1710   2          }
1711   1          //OLED_ShowString(10, 3, "GAME", OLED_6X8);
1712   1          //OLED_ShowString(86, 3, "OVER", OLED_6X8);
1713   1      }


MODULE INFORMATION:   STATIC OVERLAYABLE
   CODE SIZE        =  13756    ----
   CONSTANT SIZE    =     14    ----
   XDATA SIZE       =   1038     393
   PDATA SIZE       =   ----    ----
   DATA SIZE        =   ----       3
   IDATA SIZE       =   ----    ----
   BIT SIZE         =   ----    ----
END OF MODULE INFORMATION.


C51 COMPILATION COMPLETE.  1 WARNING(S),  0 ERROR(S)
